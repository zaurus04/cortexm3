/*
 *  TOPPERS/JSP Kernel
 *      Toyohashi Open Platform for Embedded Real-Time Systems/
 *      Just Standard Profile Kernel
 * 
 *  Copyright (C) 2003-2004 by Naoki Saito
 *             Nagoya Municipal Industrial Research Institute, JAPAN
 * 
 *  上記著作権者は，以下の (1)〜(4) の条件か，Free Software Foundation 
 *  によって公表されている GNU General Public License の Version 2 に記
 *  述されている条件を満たす場合に限り，本ソフトウェア（本ソフトウェア
 *  を改変したものを含む．以下同じ）を使用・複製・改変・再配布（以下，
 *  利用と呼ぶ）することを無償で許諾する．
 *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
 *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
 *      スコード中に含まれていること．
 *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
 *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
 *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
 *      の無保証規定を掲載すること．
 *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
 *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
 *      と．
 *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
 *        作権表示，この利用条件および下記の無保証規定を掲載すること．
 *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
 *        報告すること．
 *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
 *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
 * 
 *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
 *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，その適用可能性も
 *  含めて，いかなる保証も行わない．また，本ソフトウェアの利用により直
 *  接的または間接的に生じたいかなる損害に関しても，その責任を負わない．
 * 
 *  @(#) $Id: makeoffset.c,v 1.1 2008/06/17 00:04:46 suikan Exp $
 */


/*
 *	offset.inc (もしくは offset.h) について
 *
 *	  offset.inc は構造体の特定の要素が構造体の先頭から何バイト目に
 *	存在するかということや, 特定のビットフィールドが先頭から
 *	何バイト先の何ビット目に存在するか, という情報を
 *	アセンブリ言語ファイルに与えるために存在している.
 *
 *	  offset.inc ファイルの中身は, 単なるシンボル定義ファイルである.
 *	シンボルといっても定義するシンボルの名称にはパターンがあり,
 *	大きく分けて次の3種類に分類できる.
 *
 *	<構造体名>_<要素名>	(例) TCB_sp, TCB_pc, TCB_enatex など
 *	<構造体名>_<要素名>_bit	(例) TCB_enatex_bit など
 *	<構造体名>_<要素名>_mask (例) TCB_enatex_mask など
 *
 *	(例)
 *		TCB_texptn		.equ	14
 *		TCB_sp			.equ	20
 *		TCB_pc			.equ	24
 *		TCB_enatex		.equ	13
 *		TCB_enatex_bit		.equ	 6
 *		TCB_enatex_mask		.equ	0040H
 *
 *	  一番はじめは特定の要素が構造体の先頭から何バイト先にあるか
 *	ということを示す数値につけるラベルの名称.
 *	  二番目は特定のビットフィールド中のビットが, 下位から数えて
 *	何ビット目にあるかということを示す数値につけるラベルの名称. 
 *	0から始まる数値で表現する. 最も下位のビットは第0ビットである.
 *	  三番目は先ほどの <構造体名>_<要素名>_bit とも関連するが,
 *	特定のビットフィールド中のビットのマスク値の名称.
 *	_bit と *_mask の値の間には次の関係がある.
 *		(*_mask) == (1 << *_bit)
 * *	(例) TCB_enatex_bit が 6 の時, TCB_enatex_mask は 40H
 *
 *	  ちなみにM32C依存部の実装では, 特定ビットのチェックなどに
 *	ビット命令アドレッシングを使用しているので *_mask というラベルは
 *	使用していない.
 */

/*
 *	offset.inc の作り方(M32Cターゲット依存部向け)
 *
 *	  GNU Cコンパイラを用いているターゲット依存部については,
 *	カーネルのトップディレクトリの下にある util というディレクトリの
 *	下に genoffset という perl スクリプトが用意されているので,
 *	特に手動で offset.h を作成する必要はない.
 *	  genoffset は GNU 開発環境を想定して作成されているので,
 *	生成されるアセンブリ言語疑似命令や生成規則の異なる他の
 *	Cコンパイラにはそのまま適用できない可能性がある.
 *	  そこで, ここではWindows環境 向けの genoffset を用意せず,
 *	作り方をここに記し, 手作業で offset.inc を作成してもらうことと
 *	する. 以下にその方法を示す. なお, この方法はM32Cの開発環境や
 *	命令セットに依存しているため, 他のターゲットを使用している場合は
 *	そのまま適用できない.
 *
 *  1.	makeoffset.c というファイルからCコンパイラを使用して
 *	アセンブリ言語ファイル makeoffset.a30 を生成する.
 *	コンパイルオプションはカーネルコードに与えるものと同じ
 *	ものを与える. 
 *	ルネサス製ツール TM を使用している場合は, プロジェクトエディタの
 *	生成手順ビューから makeoffset.a30 を選び, 右クリックメニューの
 *	｢部分ビルド｣を選択することで生成できる.
 *	もしくはコマンドプロンプトでメイクファイルと同じディレクトリに
 *	移動し, "make -f メイクファイル名 makeoffset.a30" を
 *	実行しても同様の結果が得られる. (メイクファイルはTMが使用して
 *	いるものと同じファイルを指定可能)
 *
 *  2.	先ほどの 1. の作業で得られた, makeoffset.a30 ファイルから
 *	"! BEGIN XXXX"  ではじまり "! END" で終わっている部分を探す.
 *
 *	4箇所あり, それぞれ少しずつ異なるので順に説明する.
 *	(以下, 説明中ではアセンブリ言語ファイルのコメント行は省く)
 *
 * (1)	構造体の先頭からメンバへのオフセット
 *
 *	! BEGIN TCB_texptn
 *		bset	00H,0000000eH
 *	! END
 *
 *	上記"! BEGIN"の後ろの文字列がoffset.incで定義するシンボル名となる.
 *	そのシンボルの値は, 次行のbset命令の第2オペランドの値である
 *	0000000eHがそれに相当する. これが構造体の先頭からtexptnまでの
 *	オフセット値となる. したがってこの場合, offset.inc には
 *	TCB_texptn	.equ	14
 *	という行を記述する.
 *
 * (2)	構造体のメンバが構造体で, その中のメンバに対するオフセット
 *
 *	TCB_sp についてもほぼ同様だが, sp はTCB構造体の直接の
 *	メンバでなくTCB構造体のメンバであるCTXB構造体のメンバで
 *	ある点が異なる. それでも定義するシンボル名としては
 *	TCB_sp のように表現する. アセンブリ言語ファイルでは
 *
 *	! BEGIN TCB_sp
 *		mov.l	00000014H,A0
 *		extz	[A0],R0
 *		bset	0,R0L
 *		mov.l	#00000014H,A0
 *		mov.b	R0L,[[A0]]
 *	! END *
 *
 *	のようになり,14H(=20) が求める値なのでoffset.inc には次のように
 *	記述する.
 *
 *	TCB_sp	.equ	20
 *
 * (3)	メンバが関数へのポインタであった場合
 *
 *	次は TCB_pc の場合.
 *
 *	! BEGIN TCB_pc
 *		mov.l	#00000018H,A0
 *		jsri.a	[A0]
 *	! END
 *
 *	pc も sp と同じく, TCB構造体の直接のメンバではないが
 *	TCB_pc と表現している. これは関数のアドレスを格納する変数なので,
 *	(((TCB *)0)->tskctxb.pc)();
 *	として関数呼び出しのように記述すると上記のようなアセンブリ言語
 *	コードを出力する. シンボル定義する際のシンボル名は今までと
 *	同じく, TCB_pc とする. 
 *	求める値は構造体から関数ポインタまでのオフセットであり, 上のmov.l
 *	命令の結果から 	00000018H(=24) となる.
 *	したがって, offset.inc には次のように記述する.
 *
 *	TCB_pc	.equ	24
 *
 * (4)	構造体のメンバがビットフィールドでそのビット位置も知りたい場合
 *
 *	! BEGIN TCB_enatex
 *		bset	6,0000000cH+1
 *	! END
 *
 *	今までと同様, BEGIN の後の文字列をシンボル名とする.
 *	ここでのTCB_enatexの値は構造体の先頭からビットフィールドを含むバ
 *	イトまでのオフセットで, M32Cのビット命令アドレッシングは指定でき
 *	るビット位置が0から7の間に収まるようにアクセスするアドレスに適当
 *	数が加えられるので cH+1(=13) となっている. また, ビットフィールド
 *	中の最下位ビットからのビット位置は 6となる.
 *	以上より次のように書くことができる.
 *
 *		TCB_enatex	.equ	13
 *		TCB_enatex_bit	.equ	 6
 *		TCB_enatex_mask	.equ	40H
 */

#include "jsp_kernel.h"
#include "task.h"


void makeoffset(void);

void
makeoffset(void)
{
	asm("! BEGIN TCB_texptn\n");
	(INT)(((TCB *)0)->texptn) |= 1;
	asm("! END");

	asm("! BEGIN TCB_sp\n");
	*(char *)(((TCB *)0)->tskctxb.sp) |= 1;
	asm("! END");

	asm("! BEGIN TCB_pc\n");
	(((TCB *)0)->tskctxb.pc)();
	asm("! END");

	asm("! BEGIN TCB_enatex\n");
	(INT)(((TCB *)0)->enatex) = 1;
	asm("! END");
}

