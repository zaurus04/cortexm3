
		TOPPERS/ASPカーネル
		機能拡張・チューニングガイド

		対応バージョン: Release 1.3.2
		最終更新: 2008年8月1日

このドキュメントは，TOPPERS/ASPカーネルを，機能拡張・チューニングするた
めの方法（またはヒント）を説明するものである．

----------------------------------------------------------------------
 TOPPERS/ASP Kernel
     Toyohashi Open Platform for Embedded Real-Time Systems/
     Advanced Standard Profile Kernel

 Copyright (C) 2005-2008 by Embedded and Real-Time Systems Laboratory
             Graduate School of Information Science, Nagoya Univ., JAPAN
 
 上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
 ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
 変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
 (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
     権表示，この利用条件および下記の無保証規定が，そのままの形でソー
     スコード中に含まれていること．
 (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
     用できる形で再配布する場合には，再配布に伴うドキュメント（利用
     者マニュアルなど）に，上記の著作権表示，この利用条件および下記
     の無保証規定を掲載すること．
 (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
     用できない形で再配布する場合には，次のいずれかの条件を満たすこ
     と．
   (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
       作権表示，この利用条件および下記の無保証規定を掲載すること．
   (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
       報告すること．
 (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
     害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
     また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
     由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
     免責すること．
 
 本ソフトウェアは，無保証で提供されているものである．上記著作権者お
 よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
 に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
 アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
 の責任を負わない．
 
 @(#) $Id: extension.txt 1222 2008-08-03 11:45:39Z ertl-hiro $
----------------------------------------------------------------------

○目次

・エラーチェックの省略
・タイムティックの周期の変更
・特殊目的のレジスタの扱い
・ミューテックス機能
・タスク優先度の範囲の拡張
・割込みハンドラ／CPU例外ハンドラの直接呼出し


○エラーチェックの省略

サービスコールのオーバヘッドを削減するために，静的なエラーのチェックを
省略する場合がある．ASPカーネルにおいては，静的なエラーのチェックはすべ
てCHECKマクロを用いて行っているため，kernel/check.h中のCHECKマクロを編
集することで，静的なエラーのチェックを省略することができる．

例えば，タスクIDのチェックを省略したい場合には，CHECK_TSKIDマクロと
CHECK_TSKID_SELFマクロを，次のように修正すればよい．

#define CHECK_TSKID(tskid)			((void)(tskid))
#define CHECK_TSKID_SELF(tskid)		((void)(tskid))

これらのマクロの定義を空にする方法もあるが，パラメータに副作用のある式
が書かれている可能性を考えると（副作用のある式は書くべきではないが，書
かれているコードが入ってくる可能性が全くないとは言えない），上の定義の
方が安全である．副作用のない式であれば，最適化によって削除することがで
きるため，実行時効率には影響がないと期待できる．ただし，最適化によって
削除されない場合には，副作用のある式が書かれていないことを確認した上で，
マクロの定義を空にしてもよい．


○タイムティックの周期の変更

ASPカーネルでは，カーネルへタイムティックを供給する周期は1ミリ秒が標準
となっているが，低速なプロセッサでは1ミリ秒毎に割込みを処理するオーバヘッ
ドが問題になる場合がある．そこで，アプリケーションが必要とする時間精度
が粗い場合には，タイムティックの周期を長くすることで，プロセッサの処理
負荷を低減する方法がある．

タイムティックの周期の与え方はターゲット依存であるため，これが変更でき
るかどうかは，ターゲット依存部のタイマドライバの実装を調べる必要がある．
標準的には，target_kernel.h（またはそこからインクルードされるファイル）
中に定義されているTIC_NUMEとTIC_DENOを書き換えることで，変更できるよう
に実装されている．


○特殊目的のレジスタの扱い

FPUレジスタやDSPレジスタなどの特殊目的のレジスタ（以下，特殊レジスタ）
を持つプロセッサでは，レジスタの扱いについて大きく次の3つの方法が考えら
れる．

(1) 特殊レジスタをタスクのコンテキストに含めない

1つのタスクのみが特殊レジスタを使用する場合には，特殊レジスタをタスクの
コンテキストに含める必要がなく，カーネルで管理する必要がない．

(2) 特殊レジスタをタスクのコンテキストに含める

複数のタスクが特殊レジスタを使用する場合には，特殊レジスタをタスクのコ
ンテキストに含める方法が最も単純である．そのためには，タスクディスパッ
チャと割込みハンドラ/CPU例外ハンドラの出入口で，特殊レジスタを保存/復帰
するコードを追加する必要がある．実際の保存/復帰場所は，スクラッチレジス
タとそれ以外のレジスタで異なるため，注意が必要である．

(3) 特殊レジスタをコンテキストに含めるかどうかをタスク毎に指定する

特殊レジスタを使用するタスクと使用しないタスクがある場合で，すべてのタ
スクのコンテキストに特殊レジスタを含める方法ではオーバヘッドが問題にな
る場合には，特殊レジスタをコンテキストに含めるかどうかをタスク毎に指定
する方法が有力である．これを実現する方法は次の通りである．

まず，特殊レジスタをコンテキストに含めるかどうかを指定するタスク属性を
設ける．例えば，FPUレジスタであれば，タスク属性にTA_FPUを設ける．タスク
ディスパッチャでは，タスク属性を見て，その属性が設定されていれば特殊レ
ジスタを保存/復帰する．

ハードウェア的に特殊レジスタがディスエーブルできる場合には，その属性が
設定されていないタスクに切り換える時に特殊レジスタをディスエーブルする
と，誤って特殊レジスタを使った場合を検出できる．

さらに，割込みハンドラ（ISR，周期ハンドラ，アラームハンドラを含む）や
CPU例外ハンドラで特殊レジスタを使用する場合には，これらの処理単位にも
特殊レジスタを使用するかどうかの属性を設ける方法が考えられる．

ここで，タスク（または他の処理単位）が特殊レジスタを使用するかどうかは，
コンパイラやライブラリに依存する場合があるため，注意が必要である．例え
ば，浮動小数点演算を含まないプログラムであっても，コンパイラがその方が
性能が高いと判断すれば，浮動小数点命令を生成する場合がある．


○ミューテックス機能拡張パッケージ

ASPカーネルに，ミューテックス機能を追加するための拡張パッケージを用意し
ている．ただし，優先度逆転を制御するための仕組みとして，優先度上限プロ
トコル（TA_CEILING属性のミューテックス）のみをサポートし，優先度継承プ
ロトコル（TA_INHERIT属性のミューテックス）はサポートしていない．

拡張パッケージは，extension/mutexディレクトリに置いてある．拡張パッケー
ジを使用する場合には，UNIXであれば，ASPカーネルのソースファイルのトップ
ディレクトリで，

	% cp -r extension/mutex/* .

を実行する．この時，元の（拡張前の）ソースファイルは上書きされてしまう
ため，拡張しないカーネルも使用したい場合には，別のディレクトリにソース
ファイルを展開して，上のコマンドを実行すること．また，複数の拡張パッケー
ジを使う場合には，それらが衝突する可能性があるので，注意が必要である．

ミューテックス機能の拡張パッケージでは，TOPPERS_SUPPORT_MUTEXが
kernel.h中で定義されているので，これを用いて拡張パッケージを使用してい
るかどうかを判別することができる．


○タスク優先度拡張パッケージ

タスク優先度を最大256段階に拡張するための拡張パッケージを用意している．
この拡張パッケージは，タスク優先度に加えて，データ優先度，メッセージ優
先度，割込みサービスルーチン優先度も256段階に拡張する．

拡張パッケージは，extension/pri_levelディレクトリに置いてある．拡張パッ
ケージの使用方法は，ミューテックス機能と同様である．

タスク優先度の範囲の拡張パッケージでは，TOPPERS_SUPPORT_PRI_LEVELが
kernel.h中で定義されているので，これを用いて拡張パッケージを使用してい
るかどうかを判別することができる．


○割込みハンドラ／CPU例外ハンドラの直接呼出し

ハードウェアでベクタテーブルを持つプロセッサにおいて，カーネルの出入口
処理を経由せずに，ユーザが用意した割込みハンドラ／CPU例外ハンドラを呼び
出す方法を追加するには，以下のような改造を行うとよい．

●概念の整理

カーネル管理外の割込みには，カーネルの実行中にも禁止されないという意義
と，カーネル内の出入口処理を経由せずに割込みハンドラを実行できるという
意義の2つの意義がある．

TOPPERS新世代カーネル仕様では，カーネル管理外の割込みを，前者の意義のみ
を実現するものと位置づける．

後者の意義を実現する仕組み，すなわち，カーネル内の出入口処理を経由せず
に割込みハンドラを実行する仕組みについては，カーネル管理外の割込みとは
別に用意することができる．このドキュメントでは，この仕組みを，割込みハ
ンドラ／CPU例外ハンドラの直接呼出しと呼ぶ．

なお，割込みハンドラ／CPU例外ハンドラの直接呼出しは，ハードウェアでベク
タテーブルを持たないプロセッサでは意義が低い．

●TA_DIRECT属性の導入

割込みハンドラ／CPU例外ハンドラの直接呼出しを指定するために，割込みハン
ドラ属性およびCPU例外ハンドラ属性に，TA_DIRECT属性を導入する．割込みハ
ンドラにおいては，TA_NONKERNEL属性が指定されている割込みハンドラに対し
てのみ，TA_DIRECT属性を指定することができる．

●カーネルの修正箇所

カーネルの修正箇所として，TA_DIRECTの値をinclude/kernel.hで定義すること
に加えて，コンフィギュレータ設定ファイル（kernel/kernel_def.csvと
kernel/kernel.tf）を以下のように修正する必要がある．

まず，TA_DIRECTの値をコンフィギュレータが取り出すために，kernel_def.csv
に次の行を追加する．

TA_DIRECT,TA_DIRECT

kernel.tfは，次のように修正する．まず，割込みハンドラ属性のエラーチェッ
クについては，次のように修正する．

	$IF (INH.INHATR[inhno] & ~(TA_NONKERNEL|TA_DIRECT|ALT(TARGET_INHATR,0))) != 0$

また，割込みハンドラの出入口処理を生成するための記述（INTHDR_ENTRYのリ
スト）を生成する部分は，次のように修正する．

$FOREACH inhno INH.ORDER_LIST$
	$IF (INH.INHATR[inhno] & TA_DIRECT) == 0$
		INTHDR_ENTRY($INH.INHNO[inhno]$, $INH.INTHDR[inhno]$)$NL$
	$END$
$END$

また，割込みハンドラ初期化ブロックの定義を生成する部分は，次のように修
正する．

const INHINIB _kernel_inhinib_table[TNUM_INHNO] = {$NL$
$JOINEACH inhno INH.ORDER_LIST ",\n"$
	$IF (INH.INHATR[inhno] & TA_DIRECT) == 0$
		$TAB${ ($INH.INHNO[inhno]$), ($INH.INHATR[inhno]$), (FP)(INT_ENTRY($INH.INHNO[inhno]$, $INH.INTHDR[inhno]$)) }
	$ELSE$
		$TAB${ ($INH.INHNO[inhno]$), ($INH.INHATR[inhno]$), (FP)($INH.INTHDR[inhno]$) }
	$END$
$END$$NL$
};$NL$

さらに，TA_NONKERNELが指定されておらず，TA_DIRECTのみが指定されている場
合にエラーを報告する処理も追加すべきである．

CPU例外ハンドラについても，同様の修正を行う．

●ターゲット依存部での対応

ターゲット非依存部を修正せず，ターゲット依存部の修正のみでこれに対応す
ることも可能である．具体的には，TA_DIRECTの値をtarget_kernel.hで定義す
ることに加えて，コンフィギュレータ設定ファイルのターゲット依存部
（target_dev.csvとtarget.tf）を修正する必要がある．

まず，target_dev.csvに，TA_DIRECTに関する行を追加する．割込みハンドラ属
性のエラーチェックについては，TARGET_INHATRにTA_DIRECTを代入することで，
TA_DIRECTがエラーにならないようにする．

割込みハンドラの出入口処理を生成するための記述と割込みハンドラ初期化ブ
ロックの定義については，OMIT_INITILIZE_INTERRUPTを用いて標準の定義が生
成されるのを抑止し，ターゲット依存の定義で置き換えればよい．CPU例外ハン
ドラについても，同様である．

以上
