
		TOPPERS/ASPカーネル
		ターゲット依存部 ポーティングガイド

		対応バージョン: Release 1.3.2
		最終更新: 2008年8月3日

このドキュメントは，TOPPERS/ASPカーネルを，未サポートのターゲットシステ
ムにポーティングするために必要な事項を説明するものである．

----------------------------------------------------------------------
 TOPPERS/ASP Kernel
     Toyohashi Open Platform for Embedded Real-Time Systems/
     Advanced Standard Profile Kernel

 Copyright (C) 2005-2008 by Embedded and Real-Time Systems Laboratory
             Graduate School of Information Science, Nagoya Univ., JAPAN
 
 上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
 ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
 変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
 (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
     権表示，この利用条件および下記の無保証規定が，そのままの形でソー
     スコード中に含まれていること．
 (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
     用できる形で再配布する場合には，再配布に伴うドキュメント（利用
     者マニュアルなど）に，上記の著作権表示，この利用条件および下記
     の無保証規定を掲載すること．
 (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
     用できない形で再配布する場合には，次のいずれかの条件を満たすこ
     と．
   (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
       作権表示，この利用条件および下記の無保証規定を掲載すること．
   (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
       報告すること．
 (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
     害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
     また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
     由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
     免責すること．
 
 本ソフトウェアは，無保証で提供されているものである．上記著作権者お
 よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
 に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
 アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
 の責任を負わない．
 
 @(#) $Id: porting.txt 1229 2008-08-08 05:19:00Z ertl-hiro $
----------------------------------------------------------------------

○目次

１．共通事項
	1.1 ターゲット依存部の構成
	1.2 名前の衝突の防止
	1.3 多重インクルードの防止
	1.4 アセンブリ言語とのヘッダファイルの共用 
	1.5 インクルード記述の方法
	1.6 クリティカルセクションの出入処理の実現に関する制約
２．システム構築環境
	2.1 ターゲット略称とターゲット依存部のディレクトリ
	2.2 Makefileのターゲット依存部
	2.3 開発環境名とコマンド名の設定
	2.4 コンパイルオプションとオブジェクトファイルの設定
	2.5 オフセットファイルの生成方法
	2.6 リンク方法の設定
	2.7 依存関係の定義
	2.8 その他の設定
３．TOPPERS共通定義のターゲット依存部
	3.1 ターゲット識別マクロ
	3.2 整数型の最大値・最小値・ビット数
	3.3 サイズの指定された整数型，その最大値・最小値，整数定数を作るマクロ
	3.4 サイズの指定された浮動小数点型，その最大値・最小値のマクロ
	3.5 コンパイラの拡張機能のためのマクロ定義
	3.6 標準的な定義の上書き
	3.7 アサーションのための定義
４．システムインタフェースレイヤ（SIL）のターゲット依存部
	4.1 全割込みロック状態の管理
	4.2 微少時間待ち
	4.3 プロセッサのエンディアン
	4.4 メモリ空間アクセス関数
	4.5 I/O空間アクセス関数
５．カーネルAPIのターゲット依存部
	5.1 ターゲット定義でサポートする機能
	5.2 割込み優先度の範囲
	5.3 タイムティックの定義
	5.4 メモリ領域確保のための型定義
	5.5 ビットパターンのビット数
	5.6 メモリ領域確保のためのマクロ
６．カーネル実装のターゲット依存部
	6.1 カーネル実装のターゲット依存部の共通事項
		6.1.1 カーネル実装のターゲット依存部の構成要素
		6.1.2 ターゲット依存部の関数の命名規則
	6.2 トレースログ機能への対応
	6.3 システム状態の管理
		6.3.1 全割込みロック状態の管理
		6.3.2 コンテキストの管理
		6.3.3 CPUロック状態の管理
	6.4 割込みに関連するシステム状態の管理
		6.4.1 割込み優先度マスクの管理
		6.4.2 割込み要求禁止フラグの管理
		6.4.3 割込み要求のクリア
		6.4.4 割込み要求のプローブ
		6.4.5 割込みハンドラの先頭処理と末尾処理
		6.4.6 割込み要求ラインの属性の設定
	6.5 タスクディスパッチャ
		6.5.1 タスクコンテキストブロックのデータ型
		6.5.2 ディスパッチャ本体
		6.5.3 タスクコンテキストからのディスパッチ
		6.5.4 ディスパッチャの動作開始
		6.5.5 現在のコンテキストを捨ててディスパッチ
		6.5.6 タスクの起動処理
	6.6 割込みハンドラ
		6.6.1 割込みハンドラの出入口処理
		6.6.2 割込みハンドラ毎の出入口処理の生成
		6.6.3 割込みハンドラの設定
		6.6.4 割込み管理機能の初期化処理の変更
		6.6.5 デフォルトの割込みハンドラ
		6.6.6 カーネル管理外の割込み
	6.7 CPU例外ハンドラとCPU例外発生時のシステム状態の参照
		6.7.1 CPU例外ハンドラの出入口処理
		6.7.2 CPU例外ハンドラの出入口処理の生成
		6.7.3 CPU例外ハンドラの設定
		6.7.4 CPU例外管理機能の初期化処理の変更
		6.7.5 デフォルトのCPU例外ハンドラ
		6.7.6 CPU例外発生時のシステム状態の参照
	6.8 カーネルの起動・終了とスタック領域など
	6.9 カーネル内部のチューニング
		6.9.1 ビットマップサーチ
		6.9.2 ビットフィールド
	6.10 カーネル実装に関するその他の定義
		6.10.1 非タスクコンテキスト用のスタック領域
		6.10.2 空ラベルの定義
	6.11 トレースログ機能に関する設定
		6.11.1 取得できるトレースログの種類とマクロ
		6.11.2 トレースログ記録のサンプルコード
	6.12 カーネル実装のターゲット依存部のためのリネーム記述
	6.13 タイマドライバ
		6.13.1 タイマドライバのファイル構成
		6.13.2 タイマの初期化・終了処理・割込み処理
		6.13.3 性能評価用システム時刻の参照のための機能
７．コンフィギュレータ設定ファイル
	7.1 設定ファイルとターゲット依存部の位置付け
	7.2 パス2のテンプレートファイルのターゲット依存部
		7.2.1 ターゲット非依存部をインクルードする前に定義すべき変数
		7.2.2 ターゲット非依存部で定義される変数
	7.3 パス3のテンプレートファイルのターゲット依存部
	7.4 cfg1_out.cのリンクに必要なスタブの定義ファイル
８．システムサービス等のターゲット依存部
	8.0 システムサービスのターゲット依存部
	8.1 システムログ機能のターゲット依存定義
	8.2 ログタスクのターゲット依存定義
	8.3 シリアルインタフェースドライバのターゲット依存部
		8.3.1 変数，データ型，管理関数
		8.3.2 デバイスサービスルーチン
		8.3.3 コールバックルーチン
	8.4 カーネル起動メッセージの出力のターゲット依存定義
	8.5 テストプログラムのターゲット依存定義
９．その他
	9.1 ドキュメント
	9.2 パッケージ記述ファイル
１０．リファレンス
	10.1 ターゲット依存部のファイル一覧


１．共通事項

1.1 ターゲット依存部の構成

ターゲット依存部は，targetディレクトリの下に，ターゲットハードウェアと
開発環境の組み合わせ毎に用意する．ただし，ターゲット依存部の再利用性を
考慮し，プロセッサ，チップ，開発環境のみに依存する部分を，プロセッサ依
存部，チップ依存部，開発環境依存部という形で切り分けてもよい．切り分け
方は，ターゲット依存部の実装に任されている．プロセッサ依存部，チップ依
存部，開発環境依存部は，archディレクトリの下に置く．

ASPカーネルのターゲット依存部は，システム構築環境（Makefile等）のターゲッ
ト依存部，TOPPERS共通定義（t_stddef.h）のターゲット依存部，システムイン
タフェースレイヤ（SIL，sil.h）のターゲット依存部，カーネルAPI（kernel.h）
のターゲット依存部，カーネル実装のターゲット依存部，システムサービスの
ターゲット依存部等で構成される．

1.2 名前の衝突の防止

TOPPERSプロジェクトが提供するソフトウェアのために，TOPPERS_で始まるシン
ボルを予約している．ヘッダファイル中に記述され，アプリケーションから参
照できる内部シンボルは，TOPPERS_で始まる名前とする．

また，_kernel_で始まるシンボルは，カーネル内部の変数や関数のために予約
している．カーネル内部の変数や関数の名前で，リンク時にアプリケーション
の名前と衝突する可能性があるものは，リネーム記述にリストアップすること
で，コンパイル時に_kernel_で始まる名前に置き換えることとしている．

1.3 多重インクルードの防止

すべてのヘッダファイルは，多重にインクルードされるのを防止するための条
件コンパイル記述を入れることとする．例えば，target_config.hであれば，ファ
イルの先頭に

#ifndef TOPPERS_TARGET_CONFIG_H
#define TOPPERS_TARGET_CONFIG_H

を，ファイルの末尾に

#endif /* TOPPERS_TARGET_CONFIG_H */

を記述する．

1.4 アセンブリ言語とのヘッダファイルの共用 

ASPカーネルのヘッダファイルの多くは，アセンブリ言語のソースファイルから
もインクルードできるようにするために，次のルールに従って記述するものと
する．

・TOPPERS_MACRO_ONLYがマクロ定義されている場合には，アセンブリ言語では
　解釈できないマクロ定義以外の記述を除くように記述する．

・符号無し整数型の定数値は，UINT_CやULONG_Cなどの整数定数を作るためのマ
　クロを用いて記述する．ただし，アセンブリ言語のソースファイルからもイ
　ンクルードできるファイル中であっても，C言語のみで用いる定数をこれらの
　マクロを使って記述する必要はない．

また，カーネル実装においては，次のルールに従うものとする．

・アセンブリ言語からも用いる定数の定義中に型キャストを用いる場合には，
　CASTマクロを用いて記述する．

アセンブリ言語からヘッダファイルをインクルードする際には，必要に応じて，
TOPPERS_MACRO_ONLY，UINC_C，ULONG_C，CASTをマクロ定義してから，インクルー
ドしなければならない．

1.5 インクルード記述の方法

開発環境で用意されている標準ヘッダファイルおよびincludeディレクトリ下の
標準ヘッダファイルは，「#include <...>」によりインクルードする．

その他のヘッダファイルは，「#include "..."」によりインクルードする．ヘッ
ダファイルが，カレントディレクトリやインクルードするファイルと同じディ
レクトリ以外のディレクトリに置かれている場合には，次のようにパス指定を
行う．

・ターゲット依存部（target/<ターゲット名>）のディレクトリに置かれている
　場合は，パス指定を行わず，ファイル名のみを記述する．
		例）#include "target_config.h"

・archディレクトリ下のディレクトリに置かれている場合には，archディレク
　トリからの相対パスで記述する．
		例）#include "m68k_gcc/prc_config.h"

・その他の場合には，ソースプログラムのルートディレクトリ（configureが置
　かれているディレクトリ）からの相対パスで記述する．
		例）#include "pdic/upd72001/upd72001.h"

・カーネルを構成するファイルから，kernelディレクトリ下のヘッダファイル
　をインクルードする場合は，パス指定を行わず，ファイル名のみを記述する．
		例）#include "kernel_impl.h"

1.6 クリティカルセクションの出入処理の実現に関する制約

カーネル内で用いるクリティカルセクションの出入処理を実現する場合には，
メモリ上のデータ構造が書き変わる可能性があることを，何らかの方法でコン
パイラに知らせなければならない．GNU開発環境では，次のいずれかの方法でこ
の制約を満たすことができる．

(a) クリティカルセクションの出入処理の全体または出入処理の本質的な部分
	（具体的には，割込み禁止／許可する処理）を（インラインでない）通常
	の関数により実現する．

(b) クリティカルセクションの出入処理の本質的な部分をインラインアセンブ
	ラによって実現している場合には，そのインラインアセンブラのclobber変
	数リストに"memory"を追加する．

(c) クリティカルセクションの出入処理の本質的な部分が，マクロやインライ
	ン関数呼出しで実現している場合には，クリティカルセクションに入る処
	理の最後と出る処理の先頭に，Asm("":::"memory")という記述を入れる．

このような制約を設ける理由については，「TOPPERS/ASPカーネル 設計メモ」
の「カーネルのデータ構造に対するvolatile宣言について」の節を参照するこ
と．


２．システム構築環境

この節の説明は，GNU開発環境（GCC，GAS，BINUTILS，GNU Make）を用いること
を想定して記述してある．それ以外の開発環境を用いる場合には，開発環境に
あわせて修正する必要がある．

2.1 ターゲット略称とターゲット依存部のディレクトリ

新しいターゲット依存部を作成する時は，まず，ターゲット略称を定める．ター
ゲット略称は，システム略称と開発環境略称を"_"で連結したものとする．シス
テム略称と開発環境略称に用いる文字は，英小文字と数字に限定する．GNU開発
環境の開発環境略称は，"gcc"とする．例えば，システム略称が"dve68k"で，
GNU開発環境を用いる場合には，ターゲット略称は"dve68k_gcc"となる．

ターゲット依存部のファイルを置くために，targetディレクトリの下に，ター
ゲット略称を名称とするディレクトリを作成する．これをターゲット依存部ディ
レクトリと呼ぶ．

ターゲット依存部からプロセッサ依存部やチップ依存部を切り分ける場合には，
依存部略称を定める．依存部略称は，プロセッサやチップの略称と開発環境略
称を"_"で連結したものとする．プロセッサやチップの略称に用いる文字は，英
小文字と数字に限定する．例えば，プロセッサ略称が"m68k"で，GNU開発環境を
用いる場合には，依存部略称は"m68k_gcc"となる．

また，ターゲット依存部から開発環境依存部を切り分ける場合には，開発環境
略称を依存部略称とする．例えば，GNU開発環境依存部の依存部略称は，"gcc"
となる．

これらの依存部のファイルを置くために，archディレクトリの下に，依存部略
称を名称とするディレクトリを作成する．

なお，GNU開発環境以外の開発環境を用いる場合には，コンフィギュレーション
スクリプト（configure），サンプルのMakefile（sample/Makefile），一部の
ユーティリティプログラム（utils/genoffset，utils/makedep）を，その開発
環境用に用意する必要がある場合がある．その場合には，これらのファイルを，
ターゲット依存部ディレクトリ，または開発環境依存部ディレクトリに置くも
のとする．また，開発環境用のプロジェクトファイルが必要な場合には，ター
ゲット依存部ディレクトリに置くものとする．

2.2 Makefileのターゲット依存部

Makefileのターゲット依存部は，ターゲット依存部ディレクトリに置いた
Makefile.targetまたはそこからインクルードされるファイル（プロセッサ・チッ
プ・開発環境依存部で用意されるファイルなど）に含める．

2.3 開発環境名とコマンド名の設定

開発環境名とコマンド名を設定するために，Makefileのターゲット依存部で次
の変数を定義する．

(2-3-1) TOOL					開発環境名

開発環境名に定義する．GNU開発環境を用いる場合には，gccに定義する．

(2-3-2) GCC_TARGET				GNU開発環境のターゲット名

GNU開発環境を用いる場合に，GNU開発環境をconfigureする場合に指定するター
ゲット名に定義する．ここで指定したターゲット名は，開発環境のコマンド名
の先頭に付与される文字列となる．例えば，GCC_TARGETをm68k-unknown-elfに
定義した場合には，コンパイラとしてm68k-unknown-elf-gccが使われる．この
変数が定義されない場合には，単なるgccが使われる．

(2-3-3) CC						Cコンパイラドライバの名称
(2-3-4) CXX						C++コンパイラドライバの名称
(2-3-5) AS						アセンブラの名称
(2-3-6) LD						リンカの名称
(2-3-7) AR						アーカイバの名称
(2-3-8) NM						nmプログラムの名称
(2-3-9) RANLIB					ranlibプログラムの名称
(2-3-10) OBJCOPY				objcopyプログラムの名称
(2-3-11) OBJDUMP				objdumpプログラムの名称

GNU開発環境以外の開発環境を用いる場合に，それぞれのコマンドの名称に定義
する．対応するコマンドがない場合や，コマンドパラメータが異なる場合には，
Makefile中でそのコマンドを呼び出している部分を変更する必要がある．

GNU開発環境では，これらはGCC_TARGETを用いて定義されるので，定義する必要
はない．

2.4 コンパイルオプションとオブジェクトファイルの設定

Makefileのターゲット依存部で以下で説明する変数を定義する時には，":="を
用いて，それまでの定義に追加する形で行う．例えば，コンパイラに対するそ
の他のオプションとして「-Wall -g -O2」を追加したい場合には，「COPTS :=
$(COPTS) -Wall -g -O2」という記述をMakefileのターゲット依存部に含める．

(2-4-1) COPTS				コンパイラに対するその他のオプション
(2-4-2) CDEFS				マクロ定義オプション（-Dオプション）
(2-4-3) INCLUDES			ヘッダファイルのディレクトリ指定オプション
							（-Iオプション）
(2-4-4) LDFLAGS				リンカに対するその他のオプション
(2-4-5) LIBS				ライブラリリンク指定のためのオプション

ターゲットに依存して，すべてのソースファイルに共通するコンパイルオプショ
ンの追加が必要な場合には，オプションの種類毎に上に示した変数に定義する．

ほとんどの場合に，ターゲット依存部ディレクトリのMakefile.targetには，以
下の記述を含める必要がある．

----------------------------------------
INCLUDES := $(INCLUDES) -I$(TARGETDIR)
----------------------------------------

ここでSRCDIRは，Makefileにおいて，ソースプログラムのルートディレクトリ
（configureが置かれているディレクトリ）に定義されている．またTARGETDIR
は，ターゲット依存部ディレクトリに定義されている．

コンパイラの問題等で，警告メッセージが出ることを防げない状況以外では，
COPTSに-Werrorを追加することを推奨する．

----------------------------------------
COPTS := $(COPTS) -Werror
----------------------------------------

カーネルのコンパイル時に，dereferencing type-punned pointer will break
strict-aliasing rulesという警告が出る場合には，以下を追加するとよい．こ
の警告メッセージに関する詳細は，「TOPPERS/ASPカーネル 設計メモ」の「型
キャストに伴う警告メッセージ」の節を参照すること．

----------------------------------------
KERNEL_CFLAGS := $(KERNEL_CFLAGS) -fno-strict-aliasing
----------------------------------------

また，アセンブリ言語レベルの識別名が，C言語レベルの識別名の先頭に"_"が
付いたものになる場合には，CDEFSに-DTOPPERS_LABEL_ASMを追加する．

(2-4-6) SYSSVC_DIR			システムサービスのソースが置かれたディレクトリ
(2-4-7) SYSSVC_ASMOBJS		アセンブリ言語で記述されたシステムサービスの
							オブジェクト
(2-4-8) SYSSVC_COBJS		C言語で記述されたシステムサービスのオブジェクト
(2-4-9) SYSSVC_CFLAGS		システムサービスに対するコンパイルオプション
(2-4-10) SYSSVC_LIBS		システムサービスに対するライブラリリンク指定

ターゲットに依存して，システムサービス（システムログタスクやデバイスド
ライバなど）のソースが置かれたディレクトリ，それを構成するオブジェクト
ファイルのリスト，それらをコンパイルする際に適用するコンパイルオプショ
ン，その構成に必要なライブラリリンク指定を追加する場合には，上に示した
変数に定義する．

(2-4-11) KERNEL_DIR			カーネルのソースが置かれたディレクトリ
(2-4-12) KERNEL_ASMOBJS		アセンブリ言語で記述されたカーネルのオブジェクト
(2-4-13) KERNEL_COBJS		C言語で記述されたカーネルのオブジェクト
(2-4-14) KERNEL_CFLAGS		カーネルに対するコンパイルオプション

ターゲットに依存して，カーネルのソースが置かれたディレクトリ，それを構
成するオブジェクトファイルのリスト，それらをコンパイルする際に適用する
コンパイルオプションを追加する場合には，上に示した変数に定義する．

ほとんどの場合に，ターゲット依存部ディレクトリのMakefile.targetには，以
下の記述を含める必要がある．

----------------------------------------
KERNEL_DIR := $(KERNEL_DIR) $(TARGETDIR)
KERNEL_ASMOBJS := $(KERNEL_ASMOBJS) target_support.o
KERNEL_COBJS := $(KERNEL_COBJS) target_config.o target_timer.o
----------------------------------------

(2-4-15) CFG_TABS			コンフィギュレータに対するオプション

ターゲットに依存して，コンフィギュレータに対するオプションを追加する場
合には，上に示した変数に定義する．具体的には，コンフィギュレータの値取
得シンボルテーブルのターゲット依存部（target_def.csv）がある場合には，
それを指定するオプションを追加する必要がある．

ほとんどの場合に，ターゲット依存部ディレクトリのMakefile.targetには，以
下の記述を含める必要がある．

----------------------------------------
CFG_TABS := $(CFG_TABS) --cfg1-def-table $(TARGETDIR)/target_def.csv
----------------------------------------

(2-4-16) CFG1_OUT_LDFLAGS	cfg1_out.cに対するリンクオプション

ターゲットに依存して，cfg1_out.cをリンクする際に適用するオプションを追
加する場合には，上に示した変数に定義する．

(2-4-17) CFG_OBJS			システムコンフィギュレーションのためのオブ
							ジェクト

ターゲットに依存して，システムコンフィギュレーションのためのオブジェク
トファイルを（kernel_cfg.o以外に）追加する場合には，上に示した変数に定
義する．この場合，追加したオブジェクトファイルの作成ルール（コンパイル／
アセンブルルールと依存関係作成ルール）を，Makefileのターゲット依存部に
記述する必要がある．

(2-4-18) CFG2_OUT

ターゲットに依存して，コンフィギュレータのパス2でkernel_cfg.cと
kernel_cfg.h以外のファイルを生成する場合には，上に示した変数に定義する．

2.5 オフセットファイルの生成方法

アセンブリ言語で記述されるプログラムから，C言語の構造体にアクセスする場
合には，構造体の各フィールドのオフセットを参照することが必要である．
ASPカーネルでは，必要なオフセット値をファイル（標準ではoffset.h）に出力
するための仕組みとして，makeoffset.cとgenoffsetを用意している．
makeoffset.cは，どのオフセット値をファイルに出力するかを指定するもので，
ターゲット依存部で用意する必要がある．genoffsetは，現時点ではGNU開発環
境にのみ対応している．

makeoffset.cとgenoffsetを使うことで，例えば，TCB中のtexptnフィールドの
オフセット値をTCB_texptnにマクロ定義することや，TCB中のタスクコンテキス
トブロック（tskctxb）に含まれるpcフィールドのオフセット値をTCB_pcにマク
ロ定義することができる．また，TCB中のenatexフィールドのオフセット値，ビッ
ト位置，ビットマスクを，それぞれTCB_enatex，TCB_enatex_bit，
TCB_enatex_maskにマクロ定義することができる．ビット位置やビットマスクの
マクロ定義を生成する場合には，アクセスするサイズやエンディアンを指定す
る必要がある．

GNU開発環境以外を用いる場合など，この仕組みでオフセットファイルを生成で
きない時には，offset.hをターゲット依存部で用意し，Makefileのターゲット
依存部でOMIT_MAKEOFFSETを"true"に定義する．

makeoffset.cとgenoffsetに関するマニュアルは，現時点では用意できていない．
使い方がわからない場合や，機能が足りない場合には，相談されたい．

2.6 リンク方法の設定

(2-6-1) LDSCRIPT				リンカスクリプトのファイル名

開発環境に標準のリンカスクリプトが使用できない場合には，ターゲット依存
部でリンカスクリプトを用意し，そのファイル名をこの変数に定義する．

(2-6-2) TEXT_START_ADDRESS		テキストセクションの先頭番地
(2-6-3) DATA_START_ADDRESS		データセクションの先頭番地

各セクションの先頭番地の指定が必要な場合には，これらの変数に先頭番地を
定義する．

(2-6-4) START_OBJS				先頭にリンクすべきモジュール名
(2-6-5) END_OBJS				最後にリンクすべきモジュール名

ターゲットによっては，ロードモジュールの先頭と最後にリンクすべきモジュー
ルを，ターゲット依存部で用意する必要がある．多くの場合，スタートアップ
モジュールをロードモジュールの先頭にリンクする必要がある．

ロードモジュールの先頭にリンクすべきプログラムがある場合には，Makefile
のターゲット依存部において，そのオブジェクトファイル名をSTART_OBJSに定
義し，それに対するコンパイルルールと依存関係作成ルールを定義する．ロー
ドモジュールの最後にリンクすべきモジュールがある場合には，そのオブジェ
クトファイル名をEND_OBJSに定義し，それに対するコンパイルルールと依存関
係作成ルールを定義する．また，標準のスタートアップモジュール（crt0.o）
をリンクしないように，LDFLAGSに-nostdlibを追加する必要がある．さら
に，-nostdlibをつけることで標準ライブラリがリンクされなくなるため，
LIBSに-lgccを追加しなければならない．

例えば，スタートアップモジュールのソースファイルがstart.Sの場合には，
Makefileのターゲット依存部に次のような記述を入れるとよい．

----------------------------------------
# スタートアップモジュールのオブジェクトファイル名
START_OBJS = start.o

# スタートアップモジュールのコンパイルルール
$(START_OBJS): %.o: %.S
	$(CC) -c $(CFLAGS) $(KERNEL_CFLAGS) $<

# スタートアップモジュールの依存関係作成ルール
$(START_OBJS:.o=.d): %.d: %.S
	@$(PERL) $(SRCDIR)/utils/makedep -C $(CC) \
		-O "$(CFLAGS) $(KERNEL_CFLAGS)" $< >> Makefile.depend

# リンカに対するオプション
LDFLAGS := -nostdlib $(LDFLAGS)
LIBS := $(LIBS) -lgcc
----------------------------------------

また，コンパイラに標準のcrtbegin.oとcrtend.oを用いる場合には，Makefile
のターゲット依存部に次のような記述を入れるとよい．

----------------------------------------
# オブジェクトファイル名
START_OBJS = $(shell $(CC) -print-file-name=crtbegin.o)
END_OBJS = $(shell $(CC) -print-file-name=crtend.o)

# 依存関係作成ルール
$(START_OBJS:.o=.d): %.d:
$(END_OBJS:.o=.d): %.d:

# リンカに対するオプション
LDFLAGS := -nostdlib $(LDFLAGS)
LIBS := $(LIBS) -lgcc
----------------------------------------

この場合，これらのファイルをコンパイルすることはないため，コンパイルルー
ルは不要である．また，依存関係作成ルールはダミーでよい（依存関係作成ルー
ルがないとエラーになる）．

ロードモジュールの先頭にリンクすべきモジュールを，リンカスクリプト中の
STARTUPにより指定する場合には，そのオブジェクトファイル名をSTART_OBJSの
代わりにHIDDEN_OBJSに定義し，それに対するコンパイルルールと依存関係作成
ルールを定義する．LIBSとLDFLAGSについては，START_OBJSを用いる場合と同様
である．

例えば，スタートアップモジュールのソースファイルがstart.Sの場合には，
Makefileのターゲット依存部に次のような記述を入れるとよい．

----------------------------------------
# スタートアップモジュールのオブジェクトファイル名
HIDDEN_OBJS = start.o

# スタートアップモジュールのコンパイルルール
$(HIDDEN_OBJS): %.o: %.S
	$(CC) -c $(CFLAGS) $(KERNEL_CFLAGS) $<

# スタートアップモジュールの依存関係作成ルール
$(HIDDEN_OBJS:.o=.d): %.d: %.S
	@$(PERL) $(SRCDIR)/utils/makedep -C $(CC) \
		-O "$(CFLAGS) $(KERNEL_CFLAGS)" $< >> Makefile.depend

# リンカに対するオプション
LDFLAGS := -nostdlib $(LDFLAGS)
LIBS := $(LIBS) -lgcc
----------------------------------------

2.7 依存関係の定義

コンフィギュレータの各パスに対して，ターゲット依存のファイルへの依存関
係を定義する．具体的には，パス1，パス2，パス3が依存するファイルを，それ
ぞれcfg1_out.c，kernel_cfg.timestamp，$(OBJFILE)に対する依存関係の形で
記述する．

ほとんどの場合に，ターゲット依存部ディレクトリのMakefile.targetには，以
下の記述を含める必要がある．

----------------------------------------
cfg1_out.c: $(TARGETDIR)/target_def.csv
kernel_cfg.timestamp: $(TARGETDIR)/target.tf
$(OBJFILE): $(TARGETDIR)/target_check.tf
----------------------------------------

2.8 その他の設定

(2-8-1) CLEAN_FILES				cleanにより削除するファイル名

cleanにより削除するファイルをターゲット依存部で追加したい場合には，ファ
イル名をこの変数に追加定義する．

(2-8-2) REALCLEAN_FILES			realcleanにより削除するファイル名

realcleanにより削除するファイルをターゲット依存部で追加したい場合には，
ファイル名をこの変数に追加定義する．


３．TOPPERS共通定義のターゲット依存部

TOPPERS共通定義（t_stddef.h）のターゲット依存部は，target_stddef.hまた
はそこからインクルードされるファイル（プロセッサ・チップ・開発環境依存
部で用意されるヘッダファイルなど）に含める．

3.1 ターゲット識別マクロ

アプリケーションやシステムサービスでターゲットを識別するために，
"TOPPERS_"にシステム略称を大文字にした文字列を連結したもの（例えば，
"TOPPERS_DVE68K"）をマクロ定義する．

また，ターゲット依存部からプロセッサ依存部やチップ依存部を切り分けた場
合には，"TOPPERS_"に依存部略称を大文字にした文字列を連結したもの（例え
ば，"TOPPERS_M68K"）をマクロ定義する．

3.2 整数型の最大値・最小値・ビット数

(3-2-1) INT_MAX				intに格納できる最大値（C90準拠）
(3-2-2) INT_MIN				intに格納できる最小値（C90準拠）
(3-2-3) UINT_MAX			unsigned intに格納できる最大値（C90準拠）
(3-2-4) LONG_MAX			longに格納できる最大値（C90準拠）
(3-2-5) LONG_MIN			longに格納できる最小値（C90準拠）
(3-2-6) ULONG_MAX			unsigned longに格納できる最大値（C90準拠）
(3-2-7) CHAR_BIT			char型のビット数（C90準拠）

整数型の最大値・最小値・ビット数を，これらのシンボルにマクロに定義する．

これらのマクロは，C90に準拠したものである．開発環境にC90に準拠した
limits.hが用意されている場合には，これらのマクロを定義することに代えて，
limits.hをインクルードすればよい．

3.3 サイズの指定された整数型，その最大値・最小値，整数定数を作るマクロ

(3-3-1) int8_t				符号付き8ビット整数（オプション，C99準拠）
(3-3-2) uint8_t				符号無し8ビット整数（オプション，C99準拠）
(3-3-3) int16_t				符号付き16ビット整数（C99準拠）
(3-3-4) uint16_t			符号無し16ビット整数（C99準拠）
(3-3-5) int32_t				符号付き32ビット整数（C99準拠）
(3-3-6) uint32_t			符号無し32ビット整数（C99準拠）
(3-3-7) int64_t				符号付き64ビット整数（オプション，C99準拠）
(3-3-8) uint64_t			符号無し64ビット整数（オプション，C99準拠）
(3-3-9) int128_t			符号付き128ビット整数（オプション，C99準拠）
(3-3-10) uint128_t			符号無し128ビット整数（オプション，C99準拠）
(3-3-11) int_least8_t		8ビット以上の符号付き整数（C99準拠）
(3-3-12) uint_least8_t		8ビット以上の符号無し整数（C99準拠）
(3-3-13) intptr_t			ポインタを格納できるサイズの符号付き整数（C99準拠）
(3-3-14) uintptr_t			ポインタを格納できるサイズの符号無し整数（C99準拠）
(3-3-15) INT8_MAX			int8_tに格納できる最大値（オプション，C99準拠）
(3-3-16) INT8_MIN			int8_tに格納できる最小値（オプション，C99準拠）
(3-3-17) UINT8_MAX			uint8_tに格納できる最大値（オプション，C99準拠）
(3-3-18) INT16_MAX			int16_tに格納できる最大値（C99準拠）
(3-3-19) INT16_MIN			int16_tに格納できる最小値（C99準拠）
(3-3-20) UINT16_MAX			uint16_tに格納できる最大値（C99準拠）
(3-3-21) INT32_MAX			int32_tに格納できる最大値（C99準拠）
(3-3-22) INT32_MIN			int32_tに格納できる最小値（C99準拠）
(3-3-23) UINT32_MAX			uint32_tに格納できる最大値（C99準拠）
(3-3-24) INT64_MAX			int64_tに格納できる最大値（オプション，C99準拠）
(3-3-25) INT64_MIN			int64_tに格納できる最小値（オプション，C99準拠）
(3-3-26) UINT64_MAX			uint64_tに格納できる最大値（オプション，C99準拠）
(3-3-27) INT128_MAX			int128_tに格納できる最大値（オプション，C99準拠）
(3-3-28) INT128_MIN			int128_tに格納できる最小値（オプション，C99準拠）
(3-3-29) UINT128_MAX		uint128_tに格納できる最大値（オプション，C99準拠）
(3-3-30) INT_LEAST8_MAX		int_least8_tに格納できる最大値（C99準拠）
(3-3-31) INT_LEAST8_MIN		int_least8_tに格納できる最小値（C99準拠）
(3-3-32) UINT_LEAST8_MAX	uint_least8_tに格納できる最大値（C99準拠）
(3-3-33) INT8_C(val)		int_least8_t型の定数を作るマクロ（C99準拠）
(3-3-34) UINT8_C(val)		uint_least8_t型の定数を作るマクロ（C99準拠）
(3-3-35) INT16_C(val)		int16_t型の定数を作るマクロ（C99準拠）
(3-3-36) UINT16_C(val)		uint16_t型の定数を作るマクロ（C99準拠）
(3-3-37) INT32_C(val)		int32_t型の定数を作るマクロ（C99準拠）
(3-3-38) UINT32_C(val)		uint32_t型の定数を作るマクロ（C99準拠）
(3-3-39) INT64_C(val)		int64_t型の定数を作るマクロ（オプション，C99準拠）
(3-3-40) UINT64_C(val)		uint64_t型の定数を作るマクロ（オプション，C99準拠）
(3-3-41) INT128_C(val)		int128_t型の定数を作るマクロ（オプション，C99準拠）
(3-3-42) UINT128_C(val)		uint128_t型の定数を作るマクロ（オプション，C99準拠）

指定されたサイズの整数型を，これらのシンボルに型定義する．また，データ
型に格納できる最大値・最小値と，整数定数を作るマクロを，これらのシンボ
ルにマクロ定義する．

これらのデータ型およびマクロは，C99に準拠したものである．開発環境にC99
に準拠したstdint.hが用意されている場合には，これらのデータ型およびマク
ロを定義することに代えて，stdint.hをインクルードすればよい．

上でオプションと記述したものは，該当するデータ型がコンパイラでサポート
されている場合にのみ定義することを示す．

3.4 サイズの指定された浮動小数点型，その最大値・最小値のマクロ

(3-4-1) float32_t			IEEE754準拠の32ビット単精度浮動小数点数（オプ
							ション）
(3-4-2) double64_t			IEEE754準拠の64ビット倍精度浮動小数点数（オプ
							ション）
(3-4-3) FLOAT32_MIN			float32_tに格納できる最小の正規化された正の浮
							動小数点数（オプション）
(3-4-4) FLOAT32_MAX			float32_tに格納できる表現可能な最大の有限浮動
							小数点数（オプション）
(3-4-5) DOUBLE64_MIN		double64_tに格納できる最小の正規化された正の浮
							動小数点数（オプション）
(3-4-6) DOUBLE64_MAX		double64_tに格納できる表現可能な最大の有限浮動
							小数点数（オプション）

指定されたサイズ・表現形式の浮動小数点型を，これらのシンボルに型定義す
る．また，データ型に格納できる最大値・最小値を，これらのシンボルにマク
ロ定義する．

いずれも，該当するデータ型がコンパイラでサポートされている場合にのみ定
義する．

3.5 コンパイラの拡張機能のためのマクロ定義

コンパイラの拡張機能を用いるためのマクロとして，必要に応じて，以下のマ
クロの定義を含める．

(3-5-1) inline（オプション，デフォルトは未定義）
(3-5-2) Inline（オプション，デフォルトはstatic inline）

インライン関数であることを示す指定．Inlineは，コンパイル単位にローカル
なインライン関数であることを示す．

(3-5-3) asm（オプション，デフォルトは未定義）
(3-5-4) Asm（オプション，デフォルトは未定義）

インラインアセンブラを記述するための指定．Asmは，最適化により削除しては
ならないことを示す．これらは，ターゲット依存部でのみ使うマクロであるた
め，ターゲット依存部で使わないなら定義する必要はない．

(3-5-5) offsetof(structure, field)（オプション，デフォルトの定義あり）

構造体structureの中での，フィールドfieldのオフセットを求めるマクロ．

(3-5-6) alignof(type)（オプション，デフォルトの定義あり）

データ型typeのアラインメント単位を求めるマクロ．

(3-5-7) NoReturn（オプション，デフォルトは未定義）

リターンすることのない関数であることを示す指定．これは，ターゲット依存
部のみ使うマクロであるため，ターゲット依存部で使わないなら定義する必要
はない．

3.6 標準的な定義の上書き

t_stddef.hに含まれるTOPPERS共通定義の標準的な定義を上書きする場合には，
以下のマクロを定義する．

(3-6-1) TOPPERS_bool（オプション，デフォルトはint）
(3-6-2) TOPPERS_size（オプション，デフォルトはuintptr_t）
(3-6-3) TOPPERS_fp（オプション，デフォルトは他と互換性のない関数ポインタ）

それぞれ，bool_t，SIZE，FPに型定義すべきデータ型．

(3-6-4) UINT_C(val)（オプション，デフォルトはUを付加）
(3-6-5) ULONG_C(val)（オプション，デフォルトはULを付加）

それぞれ，unsigned uint型，unsigned long型の定数を作るためのマクロ．

(3-6-6) NULL（オプション，デフォルトは0）

C90準拠のC言語環境では，NULLの定義はstddef.hに含まれているため，これを
インクルードしてもよい．

(3-6-7) ERCD(mercd, sercd)（オプション）
(3-6-8) MERCD(ercd)（オプション）
(3-6-9) SERCD(ercd)（オプション）

ERCD，MERCD，SERCDの標準の定義は，符号付き整数が2の補数で表現されており，
右シフト演算子（>>）が算術シフトされることを仮定している．多くのコンパ
イラでこの仮定が成り立つが，そうでない場合には，ターゲット依存部でこれ
らの定義を上書きする必要がある．

(3-6-10) ALIGN_TYPE(addr, type)（オプション）

アドレスaddrが，データ型typeのアラインメント単位にアラインしているか
チェックするマクロ．

3.7 アサーションのための定義

t_stddef.hには，assertの定義が含まれる．assertが失敗した場合（assertの
パラメータがfalseになった場合）の処理を，ターゲット依存に用意する必要が
ある．これらの定義は，assertマクロを使用する前であれば，t_stddef.h以降
にインクルードされるファイルに含まれていてもよい．なお，assertを無効に
する（NDEBUGをマクロ定義してコンパイルする）場合には，これらを用意する
必要はない．

(3-7-1) TOPPERS_assert_abort(void)

assertが失敗した場合に，プログラムを停止させる関数．システム開発中はデ
バッガに落とすのが理想的である．システム稼働時には例外処理を行わせるこ
とになる．

(3-7-2) TOPPERS_assert_fail(exp, file, line)

assertが失敗した時の情報を表示/記録するためのマクロ．システムログ機能を
用いる場合には，t_syslog.hにシステムログ機能に記録するための定義が含ま
れているので，ターゲット依存部で用意する必要はない．


４．システムインタフェースレイヤ（SIL）のターゲット依存部

システムインタフェースレイヤ（SIL，sil.h）のターゲット依存部の定義は，
target_sil.hまたはそこからインクルードされるファイル（プロセッサ・チッ
プ・開発環境依存部で用意されるヘッダファイルなど）に含める．

4.1 全割込みロック状態の管理

SILのターゲット依存部では，全割込みロック状態へ遷移する機能と，元の状態
へ戻す機能（元の状態を記憶するために変数を使う）を提供する．全割込みロッ
ク状態であるかを判別する機能は提供する必要がない．

SILの機能は，カーネルを使用しない場合にも使用できる必要がある．そのため，
全割込みロック状態への遷移と元の状態への復帰は，カーネルを用いず，プロ
セッサのリソースを直接操作することによって実現する．また，全割込みロッ
ク状態への遷移と元の状態への復帰は，全割込みロック状態やCPUロック状態で
も行える必要がある．

保護機能を持ったカーネルでは，ユーザタスクからプロセッサのリソースを直
接操作することができないため，ユーザタスクからはこれらの機能を用いるこ
とができない．用いた場合の振舞いはターゲットプロセッサに依存するが，典
型的には，特権命令違反などのCPU例外が発生することになる．

(4-1-1) SIL_PRE_LOC

全割込みロックフラグの状態を保存するための変数を定義するマクロ．型名の
後に，変数名を続けたものに定義する．変数名は，他の名前と衝突しないよう
に，"TOPPERS_"で始まる名前にする．

(4-1-2) SIL_LOC_INT()

現在の全割込みロックフラグの状態をSIL_PRE_LOCで定義した変数に保存し，全
割込みロック状態に遷移させるマクロ．このマクロを実現する際には，「1.6
クリティカルセクションの出入処理の実現に関する制約」の節に記述されてい
る制約に従わなければならない．

(4-1-3) SIL_UNL_INT()

SIL_LOC_INT()によって変数に保存した状態に戻すマクロ．このマクロを実現す
る際には，「1.6 クリティカルセクションの出入処理の実現に関する制約」の
節に記述されている制約に従わなければならない．

4.2 微少時間待ち

(4-2-1) void sil_dly_nse(ulong_t dlytim)

dlytimで指定された以上の時間（単位はナノ秒），ループなどによって待つ関
数．

以下の関数と等価な処理を，アセンブリ言語で記述する方法を，標準的な実装
方法とする．アセンブリ言語で記述するのは，コンパイラの最適化に依存しな
いようにするためである．またこの関数は，キャッシュ等の影響を受けないよ
うに，できる限りメモリアクセスを行わないように実装すべきである．

	void sil_dly_nse(ulong_t dlytim)
	{
		dlytim -= SIL_DLY_TIM1;
		if (結果が0より大きい) {
			do {
				dlytim -= SIL_DLY_TIM2;
			} while (結果が0より大きい);
		}
	}

この関数の動作は次の通りである．dlytimがSIL_DLY_TIM1以下の場合には，最
初のif文の条件が成立せず，すぐに関数から抜ける．dlytimがSIL_DLY_TIM1よ
り大きく，(SIL_DLY_TIM1+SIL_DLY_TIM2)以下の場合には，最初のif文の条件は
成立するが，doループは1回も回らずに関数から抜ける．dlytimが
(SIL_DLY_TIM1+SIL_DLY_TIM2)より大きく，(SIL_DLY_TIM1+SIL_DLY_TIM2*2)以
下の場合には，doループを1回だけ回って関数から抜ける．その後，dlytimが
SIL_DLY_TIM2大きくなる度に，whileループを回る回数が1回ずつ増える．

なお，この関数をアセンブリ言語（または，C言語）で記述する場合，どのファ
イルに記述するかが問題になる．SILのターゲット依存部には，標準では，アセ
ンブリ言語（または，C言語）の関数定義を記述するためのファイルを用意して
いない．ターゲット依存で用意してもよいが，例外的に，カーネル実装のター
ゲット依存モジュール（target_support.Sまたはtarget_config.c）に記述して
もよい．

(4-2-2) SIL_DLY_TIM1（オプション）
(4-2-3) SIL_DLY_TIM2（オプション）

sil_dly_nseを上記の標準的な方法で実現した場合，この2つの定数をターゲッ
ト依存部でマクロ定義する．

SIL_DLY_TIM2は，上記の関数において，doループ1回の実行時間（単位はナノ秒）
に設定する．ターゲットプロセッサの命令セットにもよるが，おおよそ，減算
命令と条件分岐命令各1回の実行時間になる．SIL_DLY_TIM2が決まれば，関数呼
出しも含めた全体の時間がdlytimで指定された以上の時間になるように，
SIL_DLY_TIM1を決める．

この2つの定数値の決定を支援するプログラムとして，testディレクトリに，
test_dlynseを用意している．test_dlynseを実行すると，次のような出力が得
られる．

-- for fitting parameters --
sil_dly_nse(0): 430
sil_dly_nse(420): 430
sil_dly_nse(510): 520
sil_dly_nse(600): 610
<中略>
-- for checking boundary conditions --
sil_dly_nse(421): 520
sil_dly_nse(511): 610
sil_dly_nse(601): 700

"for fitting parameters"に続く出力は，sil_dly_nse(dlytim)を呼び出した場
合の待ち時間を測定した結果である．このプログラムを用いて，":"の右側の数
値が，dlytimよりも大きい範囲でなるべく近い値になるように，2つの定数値を
調整する．"for checking boundary conditions"に続く出力は，プログラムの
妥当性をチェックするためのもので，":"の右側の数値が，dlytimよりも大きい
ことを確認する（近い値になる必要はない）．

4.3 プロセッサのエンディアン

(4-3-1) SIL_ENDIAN_BIG
(4-3-2) SIL_ENDIAN_LITTLE

プロセッサのエンディアンにより，いずれか片方のシンボルをマクロ定義する．

(4-3-3) TOPPERS_SIL_REV_ENDIAN_UINT16（オプション）
(4-3-4) TOPPERS_SIL_REV_ENDIAN_UINT32（オプション）

それぞれ，16ビット，32ビットの符号無し整数のエンディアンを反転させるマ
クロ．プロセッサがエンディアン反転のための命令を持つ場合には，その命令
を用いて実現する．これらのシンボルをマクロ定義しない場合には，デフォル
トの定義が使われる．

4.4 メモリ空間アクセス関数

(4-4-1) TOPPERS_OMIT_SIL_ACCESS

標準のメモリ空間アクセス関数を使用せず，ターゲット依存部で用意する場合
には，このシンボルをマクロ定義する．

(4-4-2) TOPPERS_OMIT_SIL_REH_LEM
(4-4-3) TOPPERS_OMIT_SIL_WRH_LEM
(4-4-4) TOPPERS_OMIT_SIL_REH_BEM
(4-4-5) TOPPERS_OMIT_SIL_WRH_BEM
(4-4-6) TOPPERS_OMIT_SIL_REW_LEM
(4-4-7) TOPPERS_OMIT_SIL_WRW_LEM
(4-4-8) TOPPERS_OMIT_SIL_REW_BEM
(4-4-9) TOPPERS_OMIT_SIL_WRW_BEM

それぞれ，標準のsil_reh_lem，sil_wrh_lem，sil_reh_bem，sil_wrh_bem，
sil_rew_lem，sil_wrw_lem，sil_rew_bem，sil_wrw_bemを使用せず，ターゲッ
ト依存部で用意する場合には，これらのシンボルをマクロ定義する．

4.5 I/O空間アクセス関数

メモリ空間とは別にI/O空間を持つプロセッサでは，I/O空間にあるデバイスレ
ジスタをアクセスするための関数として，sil_reb_iop，sil_wrb_iop，
sil_reh_iop，sil_wrh_iop，sil_reh_lep，sil_wrh_lep，sil_reh_bep，
sil_wrh_bep，sil_rew_iop，sil_wrw_iop，sil_rew_lep，sil_wrw_lep，
sil_rew_bep，sil_wrw_bepの中で必要なものを，ターゲット依存部で用意する．


５．カーネルAPIのターゲット依存部

カーネルAPI（kernel.h）のターゲット依存部の定義は，target_kernel.hまた
はそこからインクルードされるファイル（プロセッサ・チップ・開発環境依存
部で用意されるヘッダファイルなど）に含める．

5.1 ターゲット定義でサポートする機能

(5-1-1) TOPPERS_SUPPORT_DIS_INT				dis_intをサポートする
(5-1-2) TOPPERS_SUPPORT_ENA_INT				ena_intをサポートする
(5-1-3) TOPPERS_SUPPORT_GET_UTM				get_utmをサポートする

dis_int，ena_int，get_utmをサポートする場合に，それぞれのシンボルをマク
ロ定義する．

5.2 割込み優先度の範囲

(5-2-1) TMIN_INTPRI				割込み優先度の最小値（最高値）
(5-2-2) TMAX_INTPRI				割込み優先度の最大値（最低値）

それぞれ，カーネル管理の割込み優先度の最小値（＝優先度が最高），カーネ
ル管理の割込み優先度の最大値（優先度が最低）に定義する．TMAX_INTPRIは-1に
固定されているが，対称性のために用意している．

5.3 タイムティックの定義

(5-3-1) TIC_NUME				タイムティックの周期の分子
(5-3-2) TIC_DENO				タイムティックの周期の分母

タイムティックの周期（signal_timeを呼び出す周期）を，ミリ秒単位で，
TIC_NUME/TIC_DENOに定義する．例えば，タイムティックの周期が1/30秒の場合
には，TIC_NUMEを100に，TIC_DENOを3に定義すればよい．

タイムティックの周期は，1ミリ秒とする（つまり，TIC_NUME，TIC_DENOとも1
に定義する）ことを推奨するが，シミュレーション環境や性能の低いプロセッ
サでそれが適切でない場合には，それ以外の値としてもよい．その場合でも，
可能な限り，1ミリ秒の倍数である（つまり，TIC_DENOを1に定義する）ことが
望ましい．

TIC_NUMEとTIC_DENOの定義を変更することで，タイムティックの周期を変更で
きるようにタイマドライバを実装する場合には，この2つの定数の定義はデフォ
ルト値を与えていることになる．そこで，これらの定義を「#ifndef TIC_NUME」
「#endif」で囲んで記述する．

5.4 メモリ領域確保のための型定義

(5-4-1) TOPPERS_STK_T（オプション）	スタック領域を確保するための型
(5-4-2) TOPPERS_MPF_T（オプション）	固定長メモリプール領域を確保するための型

スタック領域と固定長メモリプール領域は，標準では，intptr_t型の配列とし
て確保するが，より大きい単位でアラインさせたいなどの理由で，それ以外の
型の配列として確保する場合には，それぞれTOPPERS_STK_TとTOPPERS_MPF_Tを，
配列のベースとなるデータ型にマクロ定義する．

5.5 ビットパターンのビット数

(5-5-1) TBIT_TEXPTN（オプション）	タスク例外要因のビット数
(5-5-2) TBIT_FLGPTN（オプション）	イベントフラグのビット数

TBIT_TEXPTN，TBIT_FLGPTNの標準の定義では，整数型の有効ビット数が，その
型のsizeofにCHAR_BITを乗じたものと一致していることを仮定している．多く
のコンパイラでこの仮定が成り立つが，そうでない場合には，ターゲット依存
部でこれらの定義を上書きする必要がある．ただし，これらの値は16以上でな
ければならない．

5.6 メモリ領域確保のためのマクロ

(5-6-1) TOPPERS_ROUND_SZ（オプション）
(5-6-2) TOPPERS_COUNT_SZ（オプション）

TOPPERS_COUNT_SZ(sz, unit)は，sz/unitを切り上げた値を求めるマクロで，サ
イズがszのメモリ領域をサイズがunitのデータ型の配列で確保する場合の要素
数を求めるために用いる．TOPPERS_ROUND_SZ(sz, unit)は，sz/unitを切り上げ
たものにunitをかけた値を求めるマクロで，サイズがszのメモリ領域をサイズ
がunitのデータ型の配列で確保する場合のトータルサイズを求めるために用い
る．

それぞれ，標準のTOPPERS_ROUND_SZ，TOPPERS_COUNT_SZが適切でなく，ターゲッ
ト依存部で用意する場合には，これらのシンボルを適切な値にマクロ定義する．


６．カーネル実装のターゲット依存部

6.1 カーネル実装のターゲット依存部の共通事項

6.1.1 カーネル実装のターゲット依存部の構成要素

カーネル実装のターゲット依存部は，以下の要素で構成される．

(a) カーネル実装のターゲット依存の定義

カーネル実装のターゲット非依存部から参照されるターゲット依存の定義は，
target_config.hまたはそこからインクルードされるファイル（プロセッサ・チッ
プ・開発環境依存部で用意されるヘッダファイルなど）に含める．

ターゲットのハードウェア資源（割込みハンドラ番号やCPU例外ハンドラ番号，
デバイスレジスタの番地など）の定義は，システムサービスやアプリケーショ
ンにも有用であるため，カーネル実装のみに有用な定義を含むファイルとは切
り分けて，独立したヘッダファイルに含める．このヘッダファイルの標準的な
名称を，システム略称.h（または，チップ略称.h，プロセッサ略称.h）とする．

(b) カーネル実装のターゲット依存モジュール

カーネル実装のターゲット依存の変数定義や関数を含むモジュール．C言語で記
述される部分をtarget_config.c，アセンブリ言語で記述される部分を
target_support.Sに含める．プロセッサ・チップ・開発環境依存部を切り分け
ることや，ファイルが大きくなる場合に複数のファイルに分割することも可能
である．

(c) カーネル実装のターゲット依存部のためのリネーム記述

カーネル実装のターゲット依存部の変数名や関数名を，先頭に_kernel_を付与
した名前にリネームするためのモジュール．target_rename.defを用意し，ツー
ル（utils/genrename）により，target_rename.hとtarget_unrename.hを生成す
る．プロセッサ・チップ・開発環境依存部を切り分ける場合には，リネーム記
述も切り分ける．

(d) タイマドライバ

カーネルにタイムティックを供給する（signal_timeを周期的に呼び出す）ため
のタイマドライバのヘッダファイル，実装ファイル，システムコンフィギュレー
ションファイルを，それぞれ，target_timer.h，target_timer.c，
target_timer.cfgに含める．プロセッサ・チップ・開発環境依存部を切り分け
ることも可能である．

(e) コンフィギュレータ設定ファイル

コンフィギュレータの設定ファイルを，target_def.csv，target.tf，
target_check.tfに用意する．コンフィギュレータ設定ファイルの記述方法につ
いては，７章で説明する．

6.1.2 ターゲット依存部の関数の命名規則

カーネル実装のターゲット依存部を構成する関数の中で，t_で始まるものはタ
スクコンテキスト専用，i_で始まるものは非タスクコンテキスト専用，x_で始
まるものはいずれのコンテキストからでも呼び出すことができる関数である．

6.2 トレースログ機能への対応

カーネルのトレースログ機能の中で，ディスパッチャ，割込みハンドラ，CPU例
外ハンドラの開始・終了のトレースログ取得は，ターゲット依存部で実装する
必要がある．ほとんどのターゲットシステムにおいて，それらの処理はアセン
ブリ言語で記述されており，ターゲット非依存部向けのトレースログマクロと
同じ方法（トレースログマクロを，トレースログ取得処理のC言語記述にマクロ
定義する方法）は，とることができない．

そこで，アセンブリ言語で記述されている処理中にトレースログ取得を埋め込
む場合には，トレースログマクロが定義されていれば，それが何に定義されて
いるかは無視して，標準的なトレースログ関数がC言語で記述されていると想定
して，それを呼び出すようにコーディングする．

具体的には，下の表の左側に示したトレースログマクロが定義されていれば，
表の右側に示したC言語記述と同等の処理を行うようにコーディングする．

	トレースログマクロ		トレースログ取得処理
	-----------------------------------------------
	LOG_DSP_ENTER			log_dsp_enter(p_runtsk)
	LOG_DSP_LEAVE			log_dsp_leave(p_runtsk)
	LOG_INH_ENTER			log_inh_enter(inhno)
	LOG_INH_LEAVE			log_inh_leave(inhno)
	LOG_EXC_ENTER			log_exc_enter(excno)
	LOG_EXC_LEAVE			log_exc_leave(excno)

6.3 システム状態の管理

ASPカーネルを新たなターゲットシステムにポーティングする際に，最も重要な
作業は，カーネルが定義するシステム状態を，ハードウェア（プロセッサ）上
でどのように実現するかである．以下の記述は，TOPPERS新世代カーネルにおけ
るシステム状態の定義・意味を知っていることを前提に記述している．

6.3.1 全割込みロック状態の管理

全割込みロック状態は，NMIを除くすべての割込みをマスクした状態である．全
割込みロック状態を管理する機能は，システムインタフェースレイヤ（SIL）に
よって提供され，カーネルは全割込みロック状態を管理しない．

全割込みロック状態では，sns_kerとext_ker以外のカーネルのサービスコール
を呼ぶことはできないものとしており，呼んだ場合には何が起こるか保証して
いない．そのため，sns_kerとext_kerから呼び出されるものを除いて，カーネ
ルのターゲット依存部の関数が，全割込みロック状態で呼び出される状況は考
える必要がない．

6.3.2 コンテキストの管理

処理単位が実行されるコンテキストは，タスクコンテキストと非タスクコンテ
キストに分類される．

ターゲット依存部は，実行中の処理単位が，タスクコンテキストで実行されて
いるか非タスクコンテキストで実行されているかを判別する機能を提供する．
また，CPU例外が発生したコンテキストについて判別する機能を提供する．

ターゲット依存部では，割込みハンドラとCPU例外ハンドラの入口処理で非タス
クコンテキストに切り換え，それらの出口処理で元のコンテキストに戻す．ま
た，ディスパッチャの内部で一時的に非タスクコンテキストに切り換える．

(6-3-2-1) bool_t sense_context(void)

実行中の処理単位が，タスクコンテキストで実行されている場合にはfalse，非
タスクコンテキストで実行されている場合にはtrueを返す関数．

6.3.3 CPUロック状態の管理

ターゲット依存部は，CPUロック状態へ遷移する機能，CPUロック解除状態へ遷
移する機能，CPUロック状態であるかを判別する機能を提供する．

(6-3-3-1) void t_lock_cpu(void)
(6-3-3-2) void i_lock_cpu(void)
(6-3-3-3) void x_lock_cpu(void)

CPUロック解除状態から，CPUロック状態へ遷移させる関数．これらの関数は，
CPUロック状態で呼び出されることはなく，呼び出された場合の動作は保証する
必要がない．

これらの関数を実現する際には，「1.6 クリティカルセクションの出入処理の
実現に関する制約」の節に記述されている制約に従わなければならない．

(6-3-3-4) void t_unlock_cpu(void)
(6-3-3-5) void i_unlock_cpu(void)
(6-3-3-6) void x_unlock_cpu(void)

CPUロック状態から，CPUロック解除状態へ遷移させる関数．これらの関数は，
CPUロック解除状態で呼び出されることはなく，呼び出された場合の動作は保証
する必要がない．

タスクコンテキストでCPUロック状態に遷移した場合には，CPUロック解除状態
に戻るのはタスクコンテキストに限られ，非タスクコンテキストでCPUロック解
除状態に戻ることはない．言い換えると，t_unlock_cpuが呼び出されるのは，
t_lock_cpuによってCPUロック状態になっている時である．i_lock_cpuによって
CPUロック状態になっている時には，t_unlock_cpuが呼び出されることはない．

同様に，非タスクコンテキストでCPUロック状態に遷移した場合には，CPUロッ
ク解除状態に戻るのは非タスクコンテキストに限られ，タスクコンテキストで
CPUロック解除状態に戻ることはない．言い換えると，i_unlock_cpuが呼び出さ
れるのは，i_lock_cpuによってCPUロック状態になっている時である．
t_lock_cpuによってCPUロック状態になっている時には，i_unlock_cpuが呼び出
されることはない．

これらの関数を実現する際には，「1.6 クリティカルセクションの出入処理の
実現に関する制約」の節に記述されている制約に従わなければならない．

(6-3-3-7) bool_t t_sense_lock(void)
(6-3-3-8) bool_t i_sense_lock(void)
(6-3-3-9) bool_t x_sense_lock(void)

現在のシステム状態が，CPUロック状態の場合はtrue，CPUロック解除状態の場
合にはfalseを返す関数．

これらの関数が全割込みロック状態で呼び出される状況は考える必要がないこ
とから，全割込みロック状態とCPUロック状態を区別できる必要はない．NMI以
外にカーネルの管理外の割込みを設けない場合には，全割込みロック状態と
CPUロック状態が全く同一の状態でもかまわない．

6.4 割込みに関連するシステム状態の管理

6.4.1 割込み優先度マスクの管理

ターゲット依存部は，割込み優先度マスクを設定する機能と，割込み優先度マ
スクを参照する機能を提供する．

(6-4-1-1) bool_t VALID_INTPRI_CHGIPM(PRI intpri)（オプション）

intpriが，chg_ipmに対する割込み優先度として有効な値である場合にtrue，そ
うでない場合にfalseを返すマクロ．標準では，TMIN_INTPRI以上，TIPM_ENAALL
（＝0）以下の値がchg_ipmに対する割込み優先度として有効であるが，ターゲッ
ト依存部でこのマクロを定義することで，TMIN_INTPRIよりも小さい値を有効と
することができる（有効な値の範囲を狭めてはならない）．

(6-4-1-2) void x_set_ipm(PRI intpri)
(6-4-1-3) void t_set_ipm(PRI intpri)
(6-4-1-4) void i_set_ipm(PRI intpri)

割込み優先度マスクの値をintpriに設定する関数．

これらの関数は，VALID_INTPRI_CHGIPM(intpri)がtrueを返すintpriに対しての
み呼ばれる．intpriにそうでない値が渡された場合の動作は保証する必要がな
い．

(6-4-1-5) PRI x_get_ipm(void)
(6-4-1-6) PRI t_get_ipm(void)
(6-4-1-7) PRI i_get_ipm(void)

割込み優先度マスクの値を参照して返す関数．

割込み優先度マスクを用いてカーネル管理の割込みをすべてマスクした状態は，
CPUロック状態と区別できることが必要である．具体的には，CPUロック解除状
態において，x_set_ipmを用いてカーネル管理の割込みをすべてマスクした場合
でも，x_sense_lockはfalseを返す．

それに対して，割込み優先度マスクを用いてNMIを除くすべての割込みをマスク
できる場合，その状態と全割込みロック状態を区別できる必要はなく，全く同
一の状態でもかまわない．

6.4.2 割込み要求禁止フラグの管理

ターゲット依存部は，割込み要求禁止フラグをセットする機能とクリアする機
能を提供する．

(6-4-2-1) bool_t VALID_INTNO_DISINT(INTNO intno)

intnoが，dis_int／ena_intに対する割込み番号として有効な値である場合に
true，そうでない場合にfalseを返すマクロ．割込み要求禁止フラグがセット／
クリアできないintnoに対しては，このマクロがfalseを返すようにする．

(6-4-2-2) bool_t x_disable_int(INTNO intno)
(6-4-2-3) bool_t t_disable_int(INTNO intno)
(6-4-2-4) bool_t i_disable_int(INTNO intno)

intnoで指定された割込み要求ラインに対する割込み要求禁止フラグをセットし，
trueを返す関数．指定された割込み要求ラインに対して，割込み属性が設定さ
れていない場合には，falseを返す．

これらの関数は，VALID_INTNO_DISINT(intno)がtrueとなるintnoに対してのみ
呼ばれる．intnoにそうでない値が渡された場合の動作は保証する必要がない．

dis_intサービスコールをサポートする場合（TOPPERS_SUPPORT_DIS_INTをマク
ロ定義する場合）には，t_disable_intが用意されていなければならない．

(6-4-2-5) bool_t x_enable_int(INTNO intno)
(6-4-2-6) bool_t t_enable_int(INTNO intno)
(6-4-2-7) bool_t i_enable_int(INTNO intno)

intnoで指定された割込み要求ラインに対する割込み要求禁止フラグをクリアし，
trueを返す関数．指定された割込み要求ラインに対して，割込み属性が設定さ
れていない場合には，falseを返す．

これらの関数は，VALID_INTNO_DISINT(intno)がtrueとなるintnoに対してのみ
呼ばれる．intnoにそうでない値が渡された場合の動作は保証する必要がない．

ena_intサービスコールをサポートする場合（TOPPERS_SUPPORT_ENA_INTをマク
ロ定義する場合）には，t_enable_intが用意されていなければならない．

6.4.3 割込み要求のクリア

(6-4-3-1) void x_clear_int(INTNO intno)
(6-4-3-2) void t_clear_int(INTNO intno)
(6-4-3-3) void i_clear_int(INTNO intno)

intnoで指定された割込み要求ラインがエッジトリガである場合に，トリガされ
た割込み要求をクリアする関数．intnoで指定された割込み要求ラインがレベル
トリガである場合には何もしない．

ASPカーネルのターゲット非依存部では，これらの関数を呼び出していないが，
ターゲット依存部やシステムサービスで呼び出す可能性が高いため，用意する
こととしている．

6.4.4 割込み要求のプローブ

(6-4-4-1) bool_t x_probe_int(INTNO intno)
(6-4-4-2) bool_t t_probe_int(INTNO intno)
(6-4-4-3) bool_t i_probe_int(INTNO intno)

intnoで指定された割込み要求ラインに対して，割込みが要求されている場合に
true，そうでない場合にfalseを返す関数．

ASPカーネルのターゲット非依存部では，これらの関数を呼び出していないが，
ターゲット依存部やシステムサービスで呼び出す可能性が高いため，用意する
こととしている．

6.4.5 割込みハンドラの先頭処理と末尾処理

(6-4-5-1) void i_begin_int(INTNO intno)

intnoで指定された割込み要求ラインに対する割込みハンドラの先頭で行うべき
処理を行う関数．ここで行うべき処理としては，割込み要求ラインがエッジト
リガである場合のトリガされた割込み要求のクリアが挙げられる．

intnoに対して登録された割込みサービスルーチンを呼び出す割込みハンドラの
先頭で呼び出される．

(6-4-5-2) void i_end_int(INTNO intno)

intnoで指定された割込み要求ラインに対する割込みハンドラの末尾で行うべき
処理を行う関数．ここで行うべき処理としては，割込みコントローラ（IRC）に
対する割込み処理の終了を通知が挙げられる．

intnoに対して登録された割込みサービスルーチンを呼び出す割込みハンドラの
末尾で呼び出される．

6.4.6 割込み要求ラインの属性の設定

(6-4-6-1) bool_t VALID_INTNO_CFGINT(INTNO intno)（オプション）

intnoが，CFG_INTに対する割込み番号として有効な値である場合にtrue，そう
でない場合にfalseを返すマクロ．割込み要求ラインの属性を設定できない
intnoに対しては，このマクロがfalseを返すようにする．

ASPカーネルのターゲット非依存部では，このマクロは使われていないため，ター
ゲット依存部で使わないなら，用意する必要がない．

(6-4-6-2) void x_config_int(INTNO intno, ATR intatr, PRI intpri)

intnoで指定された割込み要求ラインの割込み属性を，intatrで指定された通り
に設定する．また，割込み優先度を，intpriで指定された値に設定する．

この関数は，標準の割込み管理機能の初期化処理を用いた場合のみ，ターゲッ
ト非依存部から呼び出される．割込み管理機能の初期化処理をターゲット依存
部で用意し，その中でこの関数を呼び出さない場合には，この関数を用意する
必要はない．

intatrとして設定できる割込み属性は次の通り．

	TA_ENAINT		0x01	割込み要求禁止フラグをクリア
	TA_EDGE			0x02	エッジトリガ

この他に，ターゲット定義で割込み属性を追加してもよい．ターゲット定義で
追加するために，以下の属性名が予約されている．

	TA_POSEDGE				ポジティブエッジトリガ
	TA_NEGEDGE				ネガティブエッジトリガ
	TA_BOTHEDGE				両エッジトリガ
	TA_LOWLEVEL				ローレベルトリガ
	TA_HIGHLEVEL			ハイレベルトリガ

これらの属性名をターゲット定義で追加する場合には，その属性値を決定し，
定義をtarget_kernel.h（または，そこからインクルードされるファイル）に含
める．また，コンフィギュレータテンプレートファイルの共通部（kernel.tf）
でエラーとならないように，target_def.csv（または，そこからインクルード
されるファイル）に含め，コンフィギュレータテンプレートファイル（または，
そこからインクルードされるファイル）でTARGET_INTATRを定義する．

指定された割込み番号がCFG_INTに対するものとして有効な値でない場合や，そ
の割込み要求ラインに対して設定できない属性を指定した場合，設定できない
割込み優先度を指定した場合の動作は保証する必要がない．このようなケース
は，コンフィギュレータがエラーを検出するように，コンフィギュレータテン
プレートファイルを記述しなければならない．

6.5 タスクディスパッチャ

6.5.1 タスクコンテキストブロックのデータ型

(6-5-1-1) CTXB

ターゲット依存のタスクコンテキストを保存するために，TCB中に持つことが必
要なデータ構造の型を，CTXBに定義する．標準的には，CTXBには，タスクのス
タックポインタと実行再開番地を格納する．

6.5.2 ディスパッチャ本体

ディスパッチャ本体（dispatcher）は，ターゲット非依存部から直接呼び出さ
れることはなく，カーネルのターゲット依存部の内部からのみ呼び出される．
dispatcherは，タスクコンテキスト・CPUロック状態・ディスパッチ許可状態・
割込み優先度マスク全解除状態で呼び出される．

dispatcherの処理内容は次の通り．

----------------------------------------
void
dispatcher(void)
{
#ifdef LOG_DSP_ENTER
	log_dsp_enter(p_runtsk);
#endif /* LOG_DSP_ENTER */
  dispatcher_0:
	while ((p_runtsk = p_schedtsk) == NULL) {
		割込みを許可したらCPUロック解除状態になるよう準備する
		非タスクコンテキストに切り換える … (*1)
		do {
			割込みをすべて許可し，割込み発生を待つ … (*2)
			割込み許可前の状態に戻す（＝カーネル管理の割込みを禁止する）
		} while (!reqflg);
		reqflg = false;
		タスクコンテキストに戻す … (*1)
		CPUロック状態に戻す ... (*3)
	}
	自タスク（p_runtsk）のTCBからスタックポインタを復帰する
#ifdef LOG_DSP_LEAVE
	log_dsp_leave(p_runtsk);
#endif /* LOG_DSP_LEAVE */
	自タスクのTCBから実行再開番地を復帰し，そこへ分岐する … (*a)
}
----------------------------------------

割込み発生を待つ間に非タスクコンテキストに切り換えるのは，この間に実行
される割込みハンドラ内で，タスクディスパッチをしないようにするためであ
る．この時，割込みハンドラが，非タスクコンテキスト用のスタックを使うよ
うにしなければならない．通常は，非タスクコンテキストに切り換える際に非
タスクコンテキスト用のスタックに切り換え，タスクコンテキストに戻す際に
元のスタックに切り換える．

ターゲットによっては（特に，シミュレーション環境の場合），強制的に非タ
スクコンテキストに切り換えることが難しい場合がある．その場合には，この
間に実行される割込みハンドラ内でタスクディスパッチをしないような仕組み
を実装することで，非タスクコンテキストへの切換えを省略することができる．

(*1)の非タスクコンテキストに切り換える処理とタスクコンテキストに戻す処
理は，doループの中で行ってもよい（ターゲットによっては，割込みの許可／
禁止とまとめて処理した方が効率が良い）．

(*2)において，割込みを許可する処理と，割込み発生を待つ処理とは，不可分
に行なう必要がある．これを不可分に行なわない場合，割込みを許可した直後
に割込みが入り，その中でタスクが実行可能状態になると，実行すべきタスク
があるにもかかわらずプロセッサが割込み待ちになってしまう．

また，(*2)において，割込み発生を待つ命令が用意されていない場合や，それ
を発行するのが不都合な場合には，割込みをすべて許可して割込みを受け付け
られる状態になった後に，割込み発生を待たずに次に進んでもよい．この場合，
その外側のdoループによって，割込み発生を待つことになる．

CPUロックを解除するための情報（例えば，CPUロック前の割込み優先度マスク）
を変数に保持している場合には，(*3)でCPUロック状態に戻す際に，その変数の
値も元に戻っている必要がある．特に，その変数が，割込み待ちの間に実行し
た割込みハンドラ内で書き換えられる場合は，元の値に戻すことが必要である．

割込み待ちの間は，p_runtskをNULL（＝0）に設定しなければならない（上の処
理内容をそのまま実装すればこうなる）．このように設定しないと，割込みハ
ンドラからiget_tidを呼び出した際の動作が仕様に合致しなくなる．

(*a)において，実行再開番地は，TCBではなく，スタックに保存／復帰する方法
もある．この場合，タスクの実行開始前にスタックを使ってはならないため，
タスクの起動処理を例外扱いする必要がある．

dispatcherをアセンブリ言語で記述する場合には，トレースログ取得処理は，
「6.1.2 トレースログ機能への対応」の節で記述した方法でコーディングする
こと．なお，log_dsp_enterは切換え前のタスクのスタックで，log_dsp_leave
は切換え後のタスクのスタックで実行する．

6.5.3 タスクコンテキストからのディスパッチ

(6-5-3-1) void dispatch(void)
(6-5-3-2) OMIT_CALLTEX（オプション）
(6-5-3-3) OMIT_CALL_TEXRTN（オプション）

タスクコンテキストからのディスパッチ（dispatch）は，タスクコンテキスト
用のサービスコール処理においてタスク切換えが必要になった場合に，ターゲッ
ト非依存部のサービスコール処理関数から呼び出される．

dispatchは，タスクコンテキスト・CPUロック状態・ディスパッチ許可状態・割
込み優先度マスク全解除状態で呼び出される．

dispatchの処理内容は次の通り．

----------------------------------------
void
dispatch(void)
{
	スクラッチレジスタを除くすべてのレジスタをスタックに保存する
	スタックポインタを自タスク（p_runtsk）のTCBに保存する
	dispatch_rを，実行再開番地として自タスクのTCBに保存する … (*a)
	dispatcherに分岐する

  dispatch_r:
	スクラッチレジスタを除くすべてのレジスタをスタックから復帰する
	calltex(); … (*b)
}
----------------------------------------

dispatchを呼び出したタスクが次に実行される時には，実行再開番地として登
録したdispatch_rに戻ってくる．dispatch_rには，dispatcherのみから分岐し，
その時の状態は，タスクコンテキスト・CPUロック状態・ディスパッチ許可状態・
割込み優先度マスク全解除状態である．

(*b)でcalltexを呼ぶ代わりに，calltexの処理内容（p_runtsk->enatexがtrue
で，p_runtsk->texptnが0でない場合に，call_texrtnを呼ぶ）をここにインラ
イン展開した方が効率がよい．ターゲット非依存部のcalltexを使わない場合に
は，OMIT_CALLTEXをマクロ定義することで，ターゲット非依存部からcalltexを
取り除くことができる．さらに，call_texrtnも使わない場合のために，
OMIT_CALL_TEXRTNが用意されている．

6.5.4 ディスパッチャの動作開始

(6-5-4-1) void start_dispatch(void)

ディスパッチャの動作開始（start_dispatch）は，カーネル起動時に，カーネ
ルの初期化処理から呼び出される．start_dispatchは，リターンすることのな
い関数である．

start_dispatchは，非タスクコンテキストで，NMIを除くすべての割込みをマス
クした状態（全割込みロック状態と同等の状態）で呼び出される．start_dispatch
内で，タスクコンテキストに切り換え，CPUロック状態・割込み優先度マスク全
解除状態にしなければならない．

start_dispatchの処理内容は次の通り．

----------------------------------------
void
start_dispatch(void)
{
	タスクコンテキストに切り換える
	CPUロック状態・割込み優先度マスク全解除状態にする
	dispatcher_0に分岐する
}
----------------------------------------

6.5.5 現在のコンテキストを捨ててディスパッチ

(6-5-5-1) void exit_and_dispatch(void)

現在のコンテキストを捨ててディスパッチ（exit_and_dispatch）は，自タスク
を終了させるサービスコール処理関数から呼び出される．exit_and_dispatchは，
リターンすることのない関数である．

exit_and_dispatchは，タスクコンテキスト・CPUロック状態・ディスパッチ許
可状態・割込み優先度マスク全解除状態で呼び出される．

exit_and_dispatchの処理内容は次の通り．

----------------------------------------
void
exit_and_dispatch(void)
{
	dispatcherに分岐する
}
----------------------------------------

6.5.6 タスクの起動処理

(6-5-6-1) void activate_context(TCB *p_tcb)

タスクの起動処理（activate_context）は，タスクを休止状態から実行できる
状態にする時に呼ばれ，指定されたタスクのTCB中のスタックポインタを初期化
し，実行再開番地をタスク開始時処理（start_r）に設定する．この時点では，
指定されたタスクのスタック領域を使ってはならない．

指定されたタスクが最初に実行される時には，指定されたタスクを自タスクと
して，実行再開番地として登録したstart_rに分岐してくる．start_rには，
dispatcherのみから分岐し，その時の状態は，タスクコンテキスト・CPUロック
状態・ディスパッチ許可状態・割込み優先度マスク全解除状態である．

start_rは，CPUロック状態を解除した後，タスクの起動番地を呼び出す．さら
に，タスクの起動番地から戻ってきた場合には，ext_tskを呼び出す．

activate_contextとstart_rの処理内容は次の通り．

----------------------------------------
void
activate_context(TCB *p_tcb)
{
	指定されたタスク（p_tcb）のTCB中のスタックポインタを初期化する
	start_rを，実行再開番地として自タスクのTCBに保存する … (*a)
	return;

  start_r:
	CPUロック解除状態にする
	自タスク（p_runtsk）の起動番地を，拡張情報をパラメータとして呼び出す
	ext_tskに分岐する ... (*c)
}
----------------------------------------

(*c)でext_tskを呼ぶ代わりに，自タスクの起動番地を呼び出す時の返り番地を
ext_tskの番地としておく方法がある．

(*a)において，実行再開番地をスタックに保存／復帰する方法をとる場合には，
この時点でスタックを使ってはならないため，この処理を例外扱いしなければ
ならない．

6.6 割込みハンドラ

6.6.1 割込みハンドラの出入口処理

割込みの出入口処理の方法はプロセッサによって大きく異なるが，おおよその
処理内容は次の通り．

----------------------------------------
void
<割込みの出入口処理>(void)
{
	スクラッチレジスタをスタックに保存する
	if (タスクコンテキストで割込み発生) {
		スタックを非タスクコンテキスト用のスタックに切り換え，
								非タスクコンテキストに切り換える
	}

	多重割込みを受け付けられるようにし，CPUロック解除状態にする
#ifdef LOG_INH_ENTER
	log_inh_enter(割込みハンドラ番号);
#endif /* LOG_INH_ENTER */
	割込みハンドラを呼び出す
#ifdef LOG_INH_LEAVE
	log_inh_leave(割込みハンドラ番号);
#endif /* LOG_INH_LEAVE */

  ret_int:
	if (タスクコンテキストで割込み発生) {
		カーネル管理の割込み（または，すべての割込み）をマスクする
		スタックを元のスタックに戻し，タスクコンテキストに切り換える
		if (reqflg) {
			reqflg = false;
			CPUロック状態にする
			if (dspflg && p_runtsk != p_schedtsk) {
				スクラッチレジスタを除くすべてのレジスタをスタックに保存する
				スタックポインタを自タスク（p_runtsk）のTCBに保存する
				ret_int_rを，実行再開番地として自タスクのTCBに保存する … (*a)
				dispatcherに分岐する

			  ret_int_r:
				スクラッチレジスタを除くすべてのレジスタをスタックから復帰する
			}
			calltex(); … (*b)
			割込み処理からのリターンでCPUロック状態が解除されるよう準備する
		}
	}
	スクラッチレジスタをスタックから復帰する
	割込み処理からのリターン
}
----------------------------------------

タスクの実行中に割込みが発生し，上の処理中でdispatcherに分岐した場合，
そのタスクが次に実行される時には，実行再開番地として登録したret_int_rに
戻ってくる．ret_int_rには，dispatcherのみから分岐し，その時の状態は，タ
スクコンテキスト・CPUロック状態・ディスパッチ許可状態・割込み優先度マス
ク全解除状態である．

割込みの出入口処理をアセンブリ言語で記述する場合には，トレースログ取得
処理は，「6.1.2 トレースログ機能への対応」の節で記述した方法でコーディ
ングすること．

6.6.2 割込みハンドラ毎の出入口処理の生成

割込みベクトルをハードウェアで実現している場合など，割込みハンドラ毎に
出入口処理を用意した方が効率が良いターゲットのために，割込みハンドラ毎
に出入口処理を生成する機構を用意している．

以下のマクロは，標準の割込み管理機能の初期化処理を用いた場合のみ，ター
ゲット非依存部で使われる．割込み管理機能の初期化処理をターゲット依存部
で用意し，その中でこれらのマクロを使わない場合には，これらのマクロを用
意する必要はない．

(6-6-2-1) INT_ENTRY(inhno, inthdr)

割込みハンドラ番号がinhno，割込みハンドラの関数名がinthdrである割込みハ
ンドラの出入口処理のラベルを作るマクロ．INTHDR_ENTRYを用いて割込みハン
ドラ毎に出入口処理を生成する場合には，次のように定義する．

#define INT_ENTRY(inhno, inthdr)	_kernel_##inthdr##_##inhno

割込みハンドラ毎に出入口処理を作る必要がない場合には，次のように定義し
て，割込みハンドラの関数名をそのまま返す．

#define INT_ENTRY(inhno, inthdr)	inthdr

(6-6-2-2) INTHDR_ENTRY(inhno, inhno_num, inthdr)

割込みハンドラ番号がinhno，割込みハンドラの関数名がinthdrである割込みハ
ンドラの出入口処理を生成するマクロ．inhno_numには，アセンブリ言語記述用
に，割込みハンドラ番号が数値で渡される．割込みハンドラ毎に出入口処理を
作る必要がない場合には，空に定義する．

6.6.3 割込みハンドラの設定

(6-6-3-1) bool_t VALID_INHNO_DEFINH(INHNO inhno)（オプション）

inhnoが，DEF_INHに対する割込みハンドラ番号として有効な値である場合に
true，そうでない場合にfalseを返すマクロ．

ASPカーネルのターゲット非依存部では，このマクロは使われていないため，ター
ゲット依存部で使わないなら，用意する必要がない．

(6-6-3-2) void x_define_inh(INHNO inhno, FP int_entry)

inhnoで指定された割込みハンドラの出入口処理の番地をint_entryに設定する．

この関数は，標準の割込み管理機能の初期化処理を用いた場合のみ，ターゲッ
ト非依存部から呼び出される．割込み管理機能の初期化処理をターゲット依存
部で用意し，その中でこの関数を呼び出さない場合には，この関数を用意する
必要はない．

指定された割込みハンドラ番号がDEF_INHに対するものとして有効な値でない場
合の動作は保証されない（assertでエラーとするのが望ましい）．このような
ケースは，コンフィギュレータがエラーを検出するように，コンフィギュレー
タテンプレートファイルを記述しなければならない．

6.6.4 割込み管理機能の初期化処理の変更

(6-6-4-1) OMIT_INITIALIZE_INTERRUPT（オプション）

割込み管理機能の初期化処理をターゲット依存部で用意し，ターゲット非依存
部に含まれる標準の割込み管理機能の初期化処理を用いない場合には，このシ
ンボルをマクロ定義する．

このシンボルをマクロ定義する場合には，コンフィギュレータテンプレートファ
イルにおいて，OMIT_INITIALIZE_INTERRUPTを1に設定する．

(6-6-4-2) void initialize_interrupt(void)（オプション）

OMIT_INITIALIZE_INTERRUPTをマクロ定義した場合には，この関数をターゲット
依存部で用意する．OMIT_INITIALIZE_INTERRUPTをマクロ定義することにより取
り除かれるその他のデータ型，変数，マクロは，この関数で使用する場合にの
み用意すればよい．

6.6.5 デフォルトの割込みハンドラ

(6-6-5-1) default_int_handler(void)（オプション）

コンフィギュレータにより割込みハンドラのテーブルを生成する場合などには，
割込みハンドラを登録しなかった割込みハンドラ番号に対して，デフォルトの
割込みハンドラとして，default_int_handlerを登録する．

default_int_handlerは，標準のものをターゲット依存部で用意するが，ユーザ
が用意したもので置き換えられるように，OMIT_DEFAULT_INT_HANDLERをマクロ
定義した場合には，ターゲット依存部で定義しないようにする．なお，ユーザ
が用意する場合の名称は，_kernel_default_int_handlerとなる．

6.6.6 カーネル管理外の割込み

まず，カーネル管理外の割込みの設定方法に関して，「TOPPERS新世代カーネル
統合仕様書」の「2.7.6 カーネル管理外の割込みの設定方法」の節の3つの方法
のいずれを採用するかを決定する．

(a-1)または(a-2)を採用し，カーネル管理外とされた割込みに対して，カーネ
ルのAPIによる割込みハンドラの登録と割込み要求ラインの属性の設定をサポー
トしない場合には，それに代わる方法をターゲット依存部のユーザーズマニュ
アルに記述する．

(a-1)または(a-2)を採用してカーネルのAPIによる登録・設定をサポートする場
合や，(b)を採用した場合には，ターゲット依存部においてそれを実現する必要
がある．具体的には，次のような設定が必要になる．

・CFG_INTで使用できる割込み優先度のリスト（INTPRI_CFGINT_VALID）に，カー
　ネル管理外の割込みとなる優先度を含める．また，CFG_INTがカーネル管理外
　の割込みに対応できるようにする．

・必要な場合には，DEF_INHがカーネル管理外の割込みに対応できるようにする．
　通常は，割込みハンドラの出入口処理に関しては，カーネル管理外の割込み
　向けに特別なものを用意する必要がない．

・割込み優先度マスクにより，（NMI以外の）カーネル管理外の割込みをマスク
　できるようにする場合には，chg_ipmに対する割込み優先度として有効な値で
　あることを判別するマクロ（VALID_INTPRI_CHGIPM）の定義を変更する．

なお，カーネル管理外の割込みに対して，カーネル内の割込み出入口処理を経
由せずに割込みハンドラを実行する方法に関しては，「TOPPERS/ASPカーネル
機能拡張・チューニングガイド」の「割込みハンドラ／CPU例外ハンドラの直接
呼出し」の節を参照すること．

6.7 CPU例外ハンドラとCPU例外発生時のシステム状態の参照

6.7.1 CPU例外ハンドラの出入口処理

CPU例外の出入口処理の方法はプロセッサによって大きく異なるが，おおよその
処理内容は次の通り．

----------------------------------------
void
<CPU例外の出入口処理>(void)
{
	スクラッチレジスタをスタックに保存する
	if (タスクコンテキストでCPU例外発生) {
		スタックを非タスクコンテキスト用のスタックに切り換え，
								非タスクコンテキストに切り換える
	}
	CPU例外発生時にCPUロック状態であったかどうかを保存する

	if (CPU例外発生時にCPUロック状態であった場合) {
		CPUロック状態にする
	}
	else {
		多重割込みを受け付けられるようにし，CPUロック解除状態にする
	}
#ifdef LOG_EXC_ENTER
	log_exc_enter(CPU例外ハンドラ番号);
#endif /* LOG_EXC_ENTER */
	CPU例外ハンドラを，CPU例外の情報を記憶している領域の先頭番地を
									パラメータ（p_excinf）として呼び出す
#ifdef LOG_EXC_LEAVE
	log_exc_leave(CPU例外ハンドラ番号);
#endif /* LOG_EXC_LEAVE */

  ret_exc:
	if (タスクコンテキストでCPU例外発生) {
		カーネル管理の割込み（または，すべての割込み）をマスクする
		スタックを元のスタックに戻し，タスクコンテキストに切り換える
		if (reqflg) {
			reqflg = false;
			CPUロック状態にする
			if (dspflg && p_runtsk != p_schedtsk) {
				スクラッチレジスタを除くすべてのレジスタをスタックに保存する
				スタックポインタを自タスク（p_runtsk）のTCBに保存する
				ret_exc_rを，実行再開番地として自タスクのTCBに保存する … (*a)
				dispatcherに分岐する

			  ret_exc_r:
				スクラッチレジスタを除くすべてのレジスタをスタックから復帰する
			}
			calltex(); … (*b)
		}
	}
	CPU例外処理からのリターンで，CPUロック状態／ロック解除状態が
								CPU例外発生時の状態に戻るように準備する
	スクラッチレジスタをスタックから復帰する
	CPU例外処理からのリターン
}
----------------------------------------

ここで，reqflgがtrueの場合の処理は，割込みの出入口処理と共通であるため，
共通のルーチンを用いることができる．字面上は，「CPUロック状態が解除され
るよう準備する」と「CPUロック状態／ロック解除状態がCPU例外発生時の状態
に戻るように準備する」という違いがあるが，reqflgがtrueになるのは，CPU例
外発生時にCPUロック状態が解除されていた場合のみなので，内容的には同じ処
理となる．

CPU例外ハンドラの呼出しは，CPU例外がCPUロック状態で発生した場合にはCPU
ロック状態，CPUロック解除状態で発生した場合にはCPUロック解除状態で行わ
なければならないことに注意すること．

CPU例外の出入口処理をアセンブリ言語で記述する場合には，トレースログ取得
処理は，「6.1.2 トレースログ機能への対応」の節で記述した方法でコーディ
ングすること．

6.7.2 CPU例外ハンドラの出入口処理の生成

CPU例外ベクトルをハードウェアで実現している場合など，CPU例外ハンドラ毎
に出入口処理を用意した方が効率が良いターゲットのために，CPU例外ハンドラ
毎に出入口処理を生成する機構を用意している．

以下のマクロは，標準のCPU例外管理機能の初期化処理を用いた場合のみ，ター
ゲット非依存部で使われる．CPU例外管理機能の初期化処理をターゲット依存部
で用意し，その中でこれらのマクロを使わない場合には，これらのマクロを用
意する必要はない．

(6-7-2-1) EXC_ENTRY(excno, exchdr)

CPU例外ハンドラ番号がexcno，CPU例外ハンドラの関数名がexchdrであるCPU例
外ハンドラの出入口処理のラベルを作るマクロ．EXCHDR_ENTRYを用いてCPU例外
ハンドラ毎に出入口処理を生成する場合には，次のように定義する．

#define EXC_ENTRY(excno, exchdr)	_kernel_##exchdr##_##excno

CPU例外ハンドラ毎に出入口処理を作る必要がない場合には，次のように定義し
て，CPU例外ハンドラの関数名をそのまま返す．

#define EXC_ENTRY(excno, exchdr)	exchdr

(6-7-2-2) EXCHDR_ENTRY(excno, excno_num, exchdr)

CPU例外ハンドラ番号がexcno，CPU例外ハンドラの関数名がexchdrであるCPU例
外ハンドラの出入口処理を生成するマクロ．excno_numには，アセンブリ言語記
述用に，CPU例外ハンドラ番号が数値で渡される．CPU例外ハンドラ毎に出入口
処理を作る必要がない場合には，空に定義する．

6.7.3 CPU例外ハンドラの設定

(6-7-3-1) bool_t VALID_EXCNO_DEFEXC(EXCNO excno)（オプション）

excnoが，DEF_EXCに対するCPU例外ハンドラ番号として有効な値である場合に
true，そうでない場合にfalseを返すマクロ．

ASPカーネルのターゲット非依存部では，このマクロは使われていないため，ター
ゲット依存部で使わないなら，用意する必要がない．

(6-7-3-2) void x_define_exc(EXCNO excno, FP exc_entry)

excnoで指定されたCPU例外ハンドラの出入口処理の番地をexc_entryに設定する．

この関数は，標準のCPU例外管理機能の初期化処理を用いた場合のみ，ターゲッ
ト非依存部から呼び出される．CPU例外管理機能の初期化処理をターゲット依存
部で用意し，その中でこの関数を呼び出さない場合には，この関数を用意する
必要はない．

指定されたCPU例外ハンドラ番号がDEF_EXCに対するものとして有効な値でない
場合の動作は保証されない（assertでエラーとするのが望ましい）．このよう
なケースは，コンフィギュレータがエラーを検出するように，コンフィギュレー
タテンプレートファイルを記述しなければならない．

6.7.4 CPU例外管理機能の初期化処理の変更

(6-7-4-1) OMIT_INITIALIZE_EXCEPTION（オプション）

CPU例外管理機能の初期化処理をターゲット依存部で用意し，ターゲット非依存
部に含まれる標準の割込み管理機能の初期化処理を用いない場合には，このシ
ンボルをマクロ定義する．

このシンボルをマクロ定義する場合には，コンフィギュレータテンプレートファ
イルにおいて，OMIT_INITIALIZE_EXCEPTIONを1に設定する．

(6-7-4-2) void initialize_exception(void)（オプション）

OMIT_INITIALIZE_EXCEPTIONをマクロ定義した場合には，この関数をターゲット
依存部で用意する．OMIT_INITIALIZE_EXCEPTIONをマクロ定義することにより取
り除かれるその他のデータ型，変数，マクロは，この関数で使用する場合にの
み用意すればよい．

6.7.5 デフォルトのCPU例外ハンドラ

(6-7-5-1) default_exc_handler(void)（オプション）

コンフィギュレータによりCPU例外ハンドラのテーブルを生成する場合などには，
CPU例外ハンドラを登録しなかったCPU例外ハンドラ番号に対して，デフォルト
のCPU例外ハンドラとして，default_exc_handlerを登録する．

default_exc_handlerは，標準のものをターゲット依存部で用意するが，ユーザ
が用意したもので置き換えられるように，OMIT_DEFAULT_EXC_HANDLERをマクロ
定義した場合には，ターゲット依存部で定義しないようにする．なお，ユーザ
が用意する場合の名称は，_kernel_default_exc_handlerとなる．

6.7.6 CPU例外発生時のシステム状態の参照

(6-7-6-1) bool_t exc_sense_intmask(void *p_excinf)

CPU例外の発生した時のシステム状態が，カーネル実行中でなく，タスクコンテ
キストであり，全割込みロック状態でなく，CPUロック状態でなく，（モデル上
の）割込み優先度マスク全解除状態である時にtrue，そうでない時にfalseを返
す関数．CPU例外がカーネル管理外の割込み処理中で発生した場合にもfalseを
返す．

p_excinfには，CPU例外の情報を記憶している領域の先頭番地が渡される．

(6-7-6-2) bool_t exc_sense_unlock(void *p_excinf)

CPU例外の発生した時のシステム状態が，カーネル実行中でなく，タスクコンテ
キストであり，全割込みロック状態でなく，CPUロック状態でない時にtrue，そ
うでない時にfalseを返す関数．CPU例外がカーネル管理外の割込み処理中で発
生した場合にもfalseを返す．

p_excinfには，CPU例外の情報を記憶している領域の先頭番地が渡される．

ターゲットによっては，全割込みロック（またはCPUロック）を小さいオーバヘッ
ドで実現しようとすると，CPU例外ハンドラの中で，全割込みロック状態（また
はCPUロック状態）と割込み優先度マスクを高いレベルに設定した状態を区別で
きない場合がある．また，カーネル管理外の割込み処理中やカーネル実行中で
あることを正確に判断することも難しい．そこで，この関数がfalseを返すべき
状態であっても，これらの状態の判断を正確にするためのオーバヘッドが大き
い場合には，ターゲット定義で，安全側に倒してtrueを返すことを許容する．

6.8 カーネルの起動・終了とスタック領域など

(6-8-1) スタートアップモジュール

カーネルのスタートアップモジュールは，システムのリセット後に最初に実行
されるプログラムである．スタートアップモジュールは，標準的には，プロセッ
サ依存部またはチップ依存部で用意し以下の処理を行うが，それにこだわる必
要はない．具体的には，開発環境に用意されているスタートアップモジュール
を用いる方法（この場合，ターゲット依存部でmain関数を用意する必要がある）
や，アプリケーションで用意する場合が考えられる．

(a) プロセッサ状態の初期化

プロセッサモード，スタックポインタ，フレームポインタ等，プロセッサの状
態を初期化する．また，NMIを除くすべての割込みをマスクした状態（全割込み
ロック状態と同等の状態）とする．DRAMコントローラの初期化など，メモリを
アクセスするために必要な初期化処理をここで行ってもよい（次の
hardware_init_hookで行ってもよい）．

(b) hardware_init_hookを呼び出す

システムのリセット後すぐに行う必要のあるターゲットシステム依存の初期化
処理を行うために，hardware_init_hookを呼び出す．hardware_init_hookが用
意されていない場合は，何もしない．GNU開発環境では，リンカスクリプト中の
weak definitionにより，hardware_init_hookが用意されていない場合の値を0
とすることで，これを実現できる．weak definitionの機能を持たない開発環境
では，hardware_init_hookを必ず呼び出すことにする．

hardware_init_hookは，ターゲット依存部で用意すのが標準であるが，システ
ムのリセット後すぐに行う必要のある初期化処理を追加するために，アプリケー
ションで用意したものを用いる場合もある．

メモリアクセスに必要な初期化処理をhardware_init_hookで行う場合には，こ
れを呼び出す時点でメモリにアクセスすることができないため，関数（サブルー
チン）を呼び出すためにスタックを使用するプロセッサでは，戻り番地を汎用
レジスタに入れて呼び出すといった工夫が必要である．この場合，
hardware_init_hookをC言語で記述することはできなくなるが，やむをえない．

(c) bssセクションとdataセクションの初期化

bssセクションをクリアし，dataセクションに初期値を設定する．

ただし，カーネル本体は，kerflgがfalse（＝0）に初期化されること以外に，
これらのセクションが初期化されることに依存していないため，スタートアッ
プモジュールをアプリケーションで用意する場合で，システムサービスやアプ
リケーションがこれらのセクションが初期化されることに依存していない場合
には，システムの起動時間を短縮するために，kerflgをfalseに初期化するだけ
で十分である．

(d) software_init_hookを呼び出す

開発環境（特にライブラリ）に依存して必要な初期化処理を行うために，
software_init_hookを呼び出す．software_init_hookが用意されていない場合
は，何もしない．GNU開発環境では，リンカスクリプト中のweak definitionに
より，software_init_hookが用意されていない場合の値を0とすることで，これ
を実現できる．weak definitionの機能を持たない開発環境では，
software_init_hookを必ず呼び出すことにする．

software_init_hookは，ターゲット依存部で用意するのが標準である．

(e) sta_kerへ分岐

sta_kerを呼び出す．sta_kerは，NMIを除くすべての割込みをマスクした状態
（全割込みロック状態と同等の状態）で呼び出さなければならない．sta_kerか
らはリターンすることがないため，スタートアップモジュールに戻ってくるこ
とは考える必要がない．

(6-8-2) void target_initialize(void)

ターゲット依存部の初期化を行う関数．sta_kerの最初で呼び出される．プロセッ
サ・チップ・開発環境依存の初期化処理を，それらの依存部に切り分けること
も可能である．

この関数は，あくまでもカーネルのターゲット依存部の初期化処理を行うため
のものである．アプリケーションに必要な初期化処理は，初期化ルーチンで行
うのが基本であるが，システムのリセット後すぐに行う必要がある場合には，
hardware_init_hookを用いる．

(6-8-3) void call_exit_kernel(void)

非タスクコンテキストに切り換えて，exit_kernelへ分岐する関数．ext_kerか
ら呼び出される．exit_kernelからはリターンすることがないため，この関数に
戻ってくることは考える必要がない．

ext_kerの中で非タスクコンテキストに切り換えるのは，終了処理ルーチンを，
非タスクコンテキスト用のスタックで実行するためである．

この関数は，全割込みロック状態で呼ばれるため，全割込みロック状態から呼
び出すことができない関数を呼ばないように実装しなければならない．

(6-8-4) void call_atexit(void)

開発環境（特にライブラリ）に依存して必要な終了処理を行うために，カーネ
ル終了処理中に呼び出される関数．exit_kernelから，終了処理ルーチンの実行
後に呼び出される．

この関数は，atexitによって登録された関数とデストラクタを呼び出すことを
意図しており，標準的には，software_term_hookを呼び出す．
software_term_hookが用意されていない場合は，何もしない．GNU開発環境では，
リンカスクリプト中のweak definitionにより，software_term_hookが用意され
ていない場合の値を0とすることで，これを実現できる．weak definitionの機
能を持たない開発環境では，software_term_hookを必ず呼び出すことにする．

この関数は，全割込みロック状態で呼ばれるため，全割込みロック状態から呼
び出すことができない関数を呼ばないように実装しなければならない．

(6-8-5) void target_exit(void)

ターゲット依存部の終了処理を行う関数．この関数は，カーネル終了処理の最
後に呼び出され，リターンしてはならない．プロセッサ・チップ・開発環境依
存の終了処理を，それらの依存部に切り分けることも可能である．

この関数は，全割込みロック状態で呼ばれるため，全割込みロック状態から呼
び出すことができない関数を呼ばないように実装しなければならない．

6.9 カーネル内部のチューニング

6.9.1 ビットマップサーチ

(6-9-1-1) OMIT_BITMAP_SEARCH（オプション）
(6-9-1-2) uint_t bitmap_search(uint16_t bitmap)（オプション）

ターゲット非依存部で，uint16_t型の整数値（bitmap）中の1のビットの内，最
も下位（右）のものをサーチし，そのビット番号を返す関数bitmap_searchを用
意している．ここで，ビット番号は最下位ビットを0とし，bitmapに0を指定し
てはならないものとしている．

ビットサーチ命令を持つプロセッサでは，bitmap_searchを，ビットサーチ命令
を使うように書き直した方が効率が良い場合がある．このような場合には，ター
ゲット依存部でビットサーチ命令を使ったbitmap_searchを定義し，
OMIT_BITMAP_SEARCHをマクロ定義する．

標準ライブラリにビットサーチ命令を用いたffsがある場合，bitmap_searchを
(ffs(bitmap) - 1)に定義するとよい．

(6-9-1-3) uint16_t PRIMAP_BIT(PRI pri)（オプション）

ビットサーチ命令のサーチ方向が逆などの理由で，優先度とビットとの対応を
変更したい場合には，PRIMAP_BITをマクロ定義する．

6.9.2 ビットフィールド

(6-9-2-1) BIT_FIELD_UINT（オプション）

8ビット以下の幅のビットフィールドで，符号無し整数値を保持したい場合に用
いるべきデータ型．デフォルトの定義はunsigned intとなっているが，ターゲッ
トやツール依存で，unsigned charまたはunsigned shortに定義した方が効率が
良い場合がある．

(6-9-2-2) BIT_FIELD_BOOL（オプション）

1ビット幅のビットフィールドで，ブール値を保持したい場合に用いるべきデー
タ型．デフォルトではBIT_FIELD_UINTと同一に定義しているが，ブール値を保
持することを明示するために別の名前としている．

(6-9-2-3) TBIT_TCB_PRIORITY（オプション）

現在優先度（および，ミューテックス拡張におけるベース優先度）を保持する
ためのTCB中のフィールドのビット数．デフォルトでは8ビットに定義している
が，それ以外に定義したい場合に，ビット数をこの名前にマクロ定義する．

6.10 カーネル実装に関するその他の定義

6.10.1 非タスクコンテキスト用のスタック領域

(6-10-1-1) DEFAULT_ISTKSZ

DEF_ICSにより非タスクコンテキスト用のスタック領域が指定されない場合の，
デフォルトのスタック領域のサイズ．

(6-10-1-2) DEFAULT_ISTK（オプション）

DEF_ICSにより非タスクコンテキスト用のスタック領域が指定されない場合の，
デフォルトのスタック領域の先頭番地．このマクロが定義されない場合には，
サイズがDEFAULT_ISTKSZのスタック領域が，配列により確保される．

(6-10-1-3) STK_T *TOPPERS_ISTKPT(STK_T *istk, SIZE istksz)（オプション）

非タスクコンテキスト用のスタックポインタの初期値を保持する変数（istkpt）
を用いる場合に，このシンボルに，スタック領域の先頭番地（istk）とスタッ
ク領域のサイズ（istksz）から，スタックポインタの初期値を求めるマクロを
定義する．

6.10.2 空ラベルの定義

(6-10-2-1) TOPPERS_EMPTY_LABEL(type, symbol)（オプション）

リンクエラーを防ぐために，データ型typeの配列である変数symbolに定義を与
えるためのマクロ．与えた定義が参照されることはないため，どのような定義
を与えてもよい．

6.11 トレースログ機能に関する設定

ASPカーネルのソースコードには，カーネルの実行トレースログを取得するため
のマクロ等が埋め込んである．デフォルトでは，これらのマクロは空に定義さ
れてトレースログの取得は行わないが，これらのマクロを適切に定義すること
でトレースログの取得を行うことができる．

6.11.1 取得できるトレースログの種類とマクロ

取得できるトレースログの種類と，それを取得するために定義するマクロは次
の通りである．

(a) カーネルの動作開始と終了

次のマクロを定義することで，カーネルの動作開始時と終了時のトレースログ
を取得することができる．

	LOG_KER_ENTER		カーネルが動作を開始する直前（初期化の完了後）
	LOG_KER_LEAVE		カーネルの終了（ext_ker）が呼ばれた直後（終了処
						理の実行前）

(b) 処理単位の実行開始と終了

次のマクロを定義することで，割込みハンドラ（INH），割込みサービスルーチ
ン（ISR），周期ハンドラ（CYC），アラームハンドラ（ALM），CPU例外ハンド
ラ（EXC），タスク例外処理ルーチン（TEX）の実行開始前と終了後のトレース
ログを取得することができる．

	LOG_<処理単位略号>_ENTER	処理単位の実行開始直前
	LOG_<処理単位略号>_LEAVE	処理単位の終了直後

割込みハンドラは，アプリケーションが登録したもののみを対象とし，割込み
サービスルーチンを呼び出すためにカーネル内に生成されるものは対象としな
い．タスクの実行開始と終了は，他の方法で取得できるため，この方法は用意
していない．

なお，割込みハンドラとCPU例外ハンドラの実行開始と終了のトレースログ取得
は，ターゲット依存部で実装する必要がある．詳しくは，「6.1.2 トレースロ
グ機能への対応」「6.6.1 割込みハンドラの出入口処理」「6.7.1 CPU例外ハン
ドラの出入口処理」の節を参照すること．

(c) タスク状態の変化

次のマクロを定義することで，タスク状態が変化した時のトレースログを取得
することができる．ただし，実行状態と実行可能状態の間の遷移は，他の方法
で取得できるため，このマクロでは取得できない．

	LOG_TSKSTAT		タスク状態の変化

(d) ディスパッチャの実行開始と終了

次のマクロを定義することで，ディスパッチャが実行開始する時と，終了する
時のトレースログを取得することができる．

	LOG_DSP_ENTER	ディスパッチャの実行開始
	LOG_DSP_LEAVE	ディスパッチャの終了

ディスパッチャの実行開始は，タスクが実行状態から実行可能状態に遷移する
タイミングであるため，実行可能状態へ遷移するタスクのTCBへのポインタをパ
ラメータとする．逆に，ディスパッチャの終了は，タスクが実行可能状態から
実行状態に遷移するタイミングであるため，実行状態へ遷移するタスクのTCBへ
のポインタをパラメータとする．

ASPカーネルでは，実行できるタスクがなく，カーネルがアイドル状態になる場
合には，ディスパッチャの中に留まる．そのため，アイドル状態への遷移とア
イドル状態から他の状態への遷移は，このマクロでは取得できない．

なお，ディスパッチャの実行開始と終了のトレースログ取得は，ターゲット依
存部で実装する必要がある．詳しくは，「6.1.2 トレースログ機能への対応」
と「6.5.2 ディスパッチャ本体」の節を参照すること．

(e) サービスコールの入口と出口

次のマクロを定義することで，各サービスコールの入口と出口のトレースログ
を取得することができる．

	LOG_<サービスコールの大文字表記>_ENTER		サービスコール名の入口
	LOG_<サービスコールの大文字表記>_LEAVE		サービスコール名の出口

それぞれのマクロの名称やパラメータの詳細については，カーネルのソースコー
ドを参照すること．

6.11.2 トレースログ記録のサンプルコード

トレースログを記録する方法の一例として，メモリ上にトレースログを記録す
るためのサンプルコードをarch/logtraceディレクトリに用意している．このサ
ンプルコードは，システムログ機能と同様のトレースログ機能を用意し，トレー
スログ情報をメモリ上に記録するとともに，それを読み出して表示する機能を
実現している．

このサンプルコードを組み込む方法は次の通りである．

(1) target_config.hおよびtrace_syssvc.hに，次の記述を追加する．

	#ifdef TOPPERS_ENABLE_TRACE
	#include "logtrace/trace_config.h"
	#endif /* TOPPERS_ENABLE_TRACE */

(2) Makefile.targetに，次の記述を追加する．

	ifeq ($(ENABLE_TRACE),true)
		COPTS := $(COPTS) -DTOPPERS_ENABLE_TRACE
		KERNEL_DIR := $(KERNEL_DIR) $(SRCDIR)/arch/logtrace
		KERNEL_COBJS := $(KERNEL_COBJS) trace_config.o trace_dump.o
	endif

このサンプルコードを用いて，トレースログを記録・ダンプする方法の例につ
いては，「TOPPERS/ASPカーネル ユーザーズマニュアル」の「10.3 トレースロ
グ記録のサンプルコードの使用方法」の節を参照すること．

なお，このサンプルコードでは，ディスパッチャの出口，タスクの状態遷移，
システムログの出力の3つのトレースログのみを記録している．他のトレースロ
グを記録したい場合には，trace_config.h（およびtrace_dump.c）を修正する
必要がある．

6.12 カーネル実装のターゲット依存部のためのリネーム記述

カーネル内部に閉じて使われる関数や変数などの名称で，オブジェクトファイ
ルのシンボル表に登録されて外部から参照できる名称は，C言語レベルで，先頭
が"_kernel_"または"_KERNEL_"である名称としなければならないが，ASPカーネ
ルでは，ソースコードをコンパクトに保ちつつこれを実現するために，リネー
ム記述ファイルを導入している．

具体的には，リネームすべき名称をリストアップしたxxx_rename.defを用意し，
このファイルからツール（utils/genrename）により，名称をリネームするため
のマクロ定義を含むxxx_rename.hと，それらのマクロ定義を解除するための
xxx_unrename.hを生成する．ツールの起動方法は次の通りである．

	% genrename xxx

xxx_rename.defには，リネームすべき名称を1行に1つ記述する．xxxxという名
称が記述されている場合，xxx_rename.hには次のような記述が生成される．

#define xxxx				_kernel_xxxx
#ifdef TOPPERS_LABEL_ASM
#define _xxxx				__kernel_xxxx
#endif /* TOPPERS_LABEL_ASM */

また，xxx_unrename.hには次のような記述が生成される．

#undef xxxx
#ifdef TOPPERS_LABEL_ASM
#undef _xxxx
#endif /* TOPPERS_LABEL_ASM */

xxx_rename.defの中には，他のリネーム記述を取り込むために，「INCLUDE
"yyy"」または「INCLUDE <yyy>」という記述を含めることができる．この記述
がされている場合，xxx_rename.hには「#include "yyy_rename.h"」または
「#include <yyy_rename.h>」という記述が，xxx_unrename.hには「#include
"yyy_unrename.h"」または「#include <yyy_unrename.h>」という記述が生成さ
れる．

xxx_rename.defの中の"#"で始まる行はコメントとして読み飛ばされる．また，
空行も無視される．

カーネルのターゲット非依存部で使われる名称をリネームするために，kernel
ディレクトリに，kernel_rename.defと，そこから生成したkernel_rename.hお
よびkernel_unrename.hが用意されている．kernel_rename.defには，
「INCLUDE "target"」という記述が含まれており，ターゲット依存部のリネー
ム記述を取り込むようになっている．

ターゲット依存部では，ターゲット依存部で使われる名称をリネームするため
に，target_rename.defと，そこから生成したtarget_rename.hおよび
target_unrename.hを用意する．ターゲット依存部からプロセッサ・チップ・開
発環境依存部を切り分ける場合には，target_rename.defにINCLUDE記述を入れ，
プロセッサ・チップ・開発環境依存部のリネーム記述を取り込むようにする．

6.13 タイマドライバ

6.13.1 タイマドライバのファイル構成

タイマドライバを組み込むための静的APIを記述したシステムコンフィギュレー
ションファイルを，target_timer.cfgに用意する．このファイルには，タイマ
ドライバを初期化するための初期化ルーチンの追加，タイマドライバを終了さ
せるための終了処理ルーチンの追加，タイマ割込みのための割込みハンドラの
定義（または，割込みサービスルーチンの追加），タイマ割込みのための割込
み要求ラインの属性の設定の静的APIなどを含むことになる．

タイマドライバを呼び出すために必要な定義を含むヘッダファイルを，
target_timer.hに用意する．また，必要であれば，タイマドライバの実装ファ
イルをtarget_timer.cに用意する．

6.13.2 タイマの初期化・終了処理・割込み処理

(6-13-2-1) void target_timer_initialize(intptr_t exinf)

タイマを初期化し，タイマ割込みを周期的に発生させる関数．タイマ割込みの
周期は，TIC_NUMEとTIC_DENOで指定された時間と一致させる（「5.2 タイム
ティックの定義」の節を参照）．

この関数は，target_timer.cfg中に記述する静的APIにより，初期化ルーチンと
してカーネルに登録することを想定している．

(6-13-2-2) void target_timer_terminate(intptr_t exinf)

タイマの動作を停止させ，タイマ割込みを発生しないようにする関数．

この関数は，target_timer.cfg中に記述する静的APIにより，終了処理ルーチン
としてカーネルに登録することを想定している．

(6-13-2-3) void target_timer_handler(void)
    または void target_timer_isr(intptr_t exinf)

タイマ割込みにより起動される割込み処理プログラム．タイマ割込みハンドラ
として実現する場合にはtarget_timer_handler，割込みサービスルーチンとし
て実現する場合にはtarget_timer_isrの名称とする．

この関数は，target_timer.cfg中に記述する静的APIにより，割込みハンドラま
たは割込みサービスルーチンとしてカーネルに登録することを想定している．

6.13.3 性能評価用システム時刻の参照のための機能

性能評価用システム時刻の参照機能（get_utm）をサポートする場合には，タイ
マドライバで，以下のデータ型や関数などを用意する．

(6-13-3-1) CLOCK

タイマ値の内部表現のためのデータ型．

(6-13-3-2) CLOCK target_timer_get_current(void)

タイマの現在値を読み出し，内部表現で返す関数．タイマ値は，時間の経過と
ともに増加することを想定している．ハードウェアのタイマが，タイマ値が減
少するものである場合には，この関数内で増加する値となるように変換する．

(6-13-3-3) bool_t target_timer_probe_int(void)

タイマ割込み要求をチェックする関数．タイマ割込みが要求されている場合に
true，要求されていない場合にfalseを返す．

(6-13-3-4) TO_USEC(clock)

タイマ値の内部表現を，1μ秒単位に変換するためのマクロ（または関数）．
targettimer_get_currentで読み出した値を，タイマ割込み発生からの経過時間
（単位: 1μ秒）に変換するために用いる．


７．コンフィギュレータ設定ファイル

7.1 設定ファイルとターゲット依存部の位置付け

ASPカーネルのコンフィギュレータは，設定ファイルの記述に従ってファイルの
生成およびエラーチェックを行う．コンフィギュレータの設定ファイルには，
以下の4つがある．

(a) 静的APIテーブル

静的APIの一覧と，各静的APIのパラメータについて記述したファイル．静的
APIを拡張する場合以外は変更する必要がないため，ターゲット非依存部で用意
している（kernel/kernel_api.csv）．

(b) 値取得シンボルテーブル

コンフィギュレータのパス1において，パラメータ計算用C言語ファイルに出力
し，値を求めたいシンボル（一般には式）を記述するためのファイル．ターゲッ
ト非依存部では，ターゲットに依存せずに必要となるシンボルを記述したファ
イルを用意している（kernel/kernel_def.csv）．ターゲットに依存して必要と
なるシンボルがある場合には，targetディレクトリに置かれたtarget_def.csv
中に記述する．

ここで値を求めたシンボルの値は，コンフィギュレータのパス2およびパス3の
テンプレートファイル中で参照することができる．

(c) パス2のテンプレートファイル

コンフィギュレータのパス2は，テンプレートファイルに従って，カーネルの構
成・初期化ファイル（kernel_cfg.c），構成・初期化ヘッダファイル
（kernel_cfg.h）などを生成する．このテンプレートファイルは，ターゲット
非依存部とターゲット依存部に切り分けてあるが，他のファイルのターゲット
依存部とは逆に，ターゲット依存部からターゲット非依存部をインクルードす
る形になっている．

具体的には，targetディレクトリに置かれたtarget.tfで，必要な変数を定義し
た後，テンプレートファイルのターゲット非依存部（kernel/kernel.tf）をイ
ンクルードする．kernel.tfでは，カーネルのターゲット非依存部で使用する変
数定義等を生成する．kernel.tfをインクルードした後，target.tfでは，カー
ネルのターゲット依存部で使用する変数定義等を生成する．target.tfから，プ
ロセッサ依存部，チップ依存部を，開発環境依存部を切り分けてもよい．

(d) パス3のテンプレートファイル

コンフィギュレータのパス3は，テンプレートファイルに従って，静的APIの一
般定数式パラメータのチェックを行う．このテンプレートファイルも，ターゲッ
ト非依存部とターゲット依存部に切り分けてあり，ターゲット依存部からター
ゲット非依存部をインクルードする形になっている．

具体的には，targetディレクトリに置かれたtarget_check.tfで，必要な変数を
定義した後，テンプレートファイルのターゲット非依存部
（kernel/kernel_check.tf）をインクルードする．kernel_check.tfでは，カー
ネルのターゲット非依存部で初期化ブロックに出力した一般定数式パラメータ
のチェックを行う．kernel_check.tfをインクルードした後，target_check.tf
では，ターゲットに依存するチェックを行う．target_check.tfから，プロセッ
サ依存部，チップ依存部を，開発環境依存部を切り分けてもよい．

なお，コンフィギュレータの詳細仕様と設定ファイルの記述方法については，
別途PDFファイルの形で配布している「TOPPERS新世代カーネル用コンフィギュ
レータ仕様」および「TOPPERS新世代カーネル用コンフィギュレータ内蔵マクロ
プロセッサ仕様」を参照すること．

7.2 パス2のテンプレートファイルのターゲット依存部

以下では，パス2のテンプレートファイルのターゲット依存部を記述する上で必
要な事項について説明する．

7.2.1 ターゲット非依存部をインクルードする前に定義すべき変数

target.tfからkernel.tfをインクルードする前に，次の変数を定義しておかな
ければならない．

(7-2-1) INTNO_ATTISR_VALID		ATT_ISRで使用できる割込み番号
(7-2-2) INHNO_ATTISR_VALID		INTNO_ATTISR_VALIDに対応する割込ハンドラ番号
(7-2-3) INHNO_DEFINH_VALID		DEF_INTで使用できる割込みハンドラ番号
(7-2-4) EXCNO_DEFEXC_VALID		DEF_EXCで使用できるCPU例外ハンドラ番号
(7-2-5) INTNO_CFGINT_VALID		CFG_INTで使用できる割込み番号
(7-2-6) INTPRI_CFGINT_VALID		CFG_INTで使用できる割込み優先度

APIで使用できる割込み番号／割込みハンドラ番号／CPU例外ハンドラ番号／割
込み優先度のリストを，各変数に定義する．INHNO_ATTISR_VALIDには，
INTNO_ATTISR_VALIDにリストアップした割込み番号に対応する割込みハンドラ
番号のリストを定義する．

(7-2-7) TARGET_TSKATR（オプション）		ターゲット定義のタスク属性
(7-2-8) TARGET_ISRATR（オプション）		ターゲット定義のISR属性
(7-2-9) TARGET_INHATR（オプション）		ターゲット定義の割込みハンドラ属性
(7-2-10) TARGET_INTATR（オプション）	ターゲット定義の割込み属性
(7-2-11) TARGET_EXCATR（オプション）	ターゲット定義のCPU例外ハンドラ属性

各オブジェクトの属性を，ターゲット定義に拡張する場合に，該当するオブジェ
クト属性を示す変数に，拡張に使用するビットの論理和を定義する．これによ
り，拡張に使用するビットが設定されている場合に，エラーになるのを防ぐ．

(7-2-12) OMIT_INITIALIZE_INTERRUPT（オプション）

カーネル実装のターゲット依存部において，OMIT_INITIALIZE_INTERRUPTを定義
した場合に，この変数を1に定義する．

これにより，INHINIB，INTINIB，TNUM_INHNO，tnum_inhno，inhinib_table，
TNUM_INTNO，tnum_intno，intinib_table，initialize_interruptの定義と，割
込みハンドラ毎の出入口処理を生成するための記述（INTHDR_ENTRYマクロのリ
スト）が，kernel_cfg.cから取り除かれる．

(7-2-13) OMIT_INITIALIZE_EXCEPTION（オプション）

カーネル実装のターゲット依存部において，OMIT_INITIALIZE_EXCEPTIONを定義
した場合に，この変数を1に定義する．

これにより，EXCINIB，TNUM_EXCNO，tnum_excno，excinib_table，
initialize_exceptionの定義と，CPU例外ハンドラ毎の出入口処理を生成するた
めの記述（EXCHDR_ENTRYマクロのリスト）が，kernel_cfg.cから取り除かれる．

(7-2-14) CHECK_STKSZ_ALIGN（オプション）

スタック領域のサイズがある値の倍数でなければならない場合に，この変数を
その値に定義する．この変数を定義することで，kernel.tfにおいて，スタック
領域のサイズが正しくない（この変数に定義した値の倍数でない）場合のエラー
をチェックするようになる．チェックが必要ない場合には，この変数を定義し
ない．

7.2.2 ターゲット非依存部で定義される変数

kernel.tfの中では次の変数が定義されるため，kernel.tfをインクルードした
後，target.tfの中でこれらを参照することができる．

(7-3-1) INTNO[inhno]		inhnoを対応するintnoに変換するための連想配列
(7-3-2) INHNO[intno]		intnoを対応するinhnoに変換するための連想配列

7.3 パス3のテンプレートファイルのターゲット依存部

以下では，パス3のテンプレートファイルのターゲット依存部を記述する上で必
要な事項について説明する．

target_check.tfからkernel_check.tfをインクルードする前に，必要に応じて，
次の変数を定義しておかなければならない．

(7-3-1) CHECK_FUNC_ALIGN（オプション）　関数のアライン単位
(7-3-2) CHECK_FUNC_NONNULL（オプション）関数の非NULLチェック
(7-3-3) CHECK_STACK_ALIGN（オプション）	スタック領域のアライン単位
(7-3-4) CHECK_STACK_NONNULL（オプション）スタック領域の非NULLチェック
(7-3-5) CHECK_MPF_ALIGN（オプション）	固定長メモリプール領域のアライン単位
(7-3-6) CHECK_MPF_NONNULL（オプション）	固定長メモリプール領域の非NULLチェック

関数／スタック領域／固定長メモリプール領域の先頭番地のアラインメントの
チェックを行う場合には，それぞれ，CHECK_FUNC_ALIGN／CHECK_STACK_ALIGN／
CHECK_MPF_ALIGNをアライン単位に定義する．関数／スタック領域／固定長メモ
リプール領域の先頭番地がNULLでないかのチェックを行う場合には，それぞれ
CHECK_FUNC_NONNULL／CHECK_STACK_NONNULL／CHECK_MPF_NONNULLを1に定義する．
チェックが必要ない場合には，該当する変数を定義しない．

7.4 cfg1_out.cのリンクに必要なスタブの定義ファイル

コンフィギュレータに関してターゲット依存に用意する必要があるファイルと
して，設定ファイル以外に，cfg1_out.cをリンクするために必要なスタブの定
義ファイルがある．

コンフィギュレータのパス1では，静的APIの整数定数式パラメータの値をCコン
パイラを用いて求めるために，cfg1_out.cを生成する．これをコンパイル，リ
ンクしてオブジェクトファイルを生成する際に，スタートアップモジュールか
ら参照されるシンボルの定義を与える必要がある．

この定義を与えるために，cfg1_out.cから，ターゲット依存部の
target_cfg1_out.hをインクルードしている．target_cfg1_out.h（または，そ
こからインクルードされるファイル）には，スタートアップモジュールから参
照されるシンボルのスタブの定義を含める．典型的には，以下のような定義を
含める必要がある．

----------------------------------------
void sta_ker(void)
{
}

void hardware_init_hook(void)
{
}

void software_init_hook(void)
{
}

const SIZE		_kernel_istksz = 0;

STK_T *const	_kernel_istk = NULL;
----------------------------------------


８．システムサービス等のターゲット依存部

8.0 システムサービスのターゲット依存部

シリアルポート数やシステムログタスク関連の定数など，システムサービスの
構成を決定するための定義をtarget_syssvc.hまたはそこからインクルードされ
るファイル（プロセッサ・チップ・開発環境依存部で用意されるヘッダファイ
ルなど）に含める．

なお，TOPPERS組込みコンポーネントシステムが導入されると，このファイルの
内容はコンポーネント記述ファイルに記述されることになり，このファイルは
無くなる（または，大幅に縮小される）見込みである．

8.1 システムログ機能のターゲット依存定義

ターゲット依存部で提供すべきシステムログ機能のための定義は次の通りであ
る．

(8-1-1) TCNT_SYSLOG_BUFFER

システムログ機能のログバッファのサイズを定義するマクロ．定義しない場合
のデフォルト値は32．

(8-1-2) void target_fput_log(char_t c)

システムログの低レベル出力のための文字出力関数．ターゲット依存の方法で，
文字cを表示/出力/保存する．

この関数は，全割込みロック状態で呼ばれる場合があるため，全割込みロック
状態から呼び出すことができない関数を呼ばないように実装しなければならな
い．

低レベル出力をシリアルポート経由で行う場合で，シリアルインタフェースド
ライバとポートを共用しないことが望ましいが，ポート数が足りないためにや
むをえず共用する場合には，両者が競合しないように注意が必要である．具体
的には，両者が同じ設定でシリアルI/Oデバイスを使うようにし，シリアルイン
タフェースドライバの動作中に低レベル出力が行われても差し支えないように
設計する．また，低レベル出力が動作開始後にシリアルインタフェースドライ
バがシリアルI/Oデバイスを初期化すると，文字化けが起こる可能性があるため，
共用するポートは，低レベル出力機能側で初期化し，シリアルインタフェース
ドライバでは初期化しないようにするとよい．

なお，この関数の本体を，どのファイルに記述するかが問題になる．システム
サービスのターゲット依存部には，標準では，関数定義を記述するためのファ
イルを用意していない．ターゲット依存で用意してもよいが，例外的に，カー
ネル実装のターゲット依存モジュール（target_config.c）に記述してもよい．

8.2 ログタスクのターゲット依存定義

ターゲット依存部で提供すべきログタスクのための定義は次の通りである．こ
れらの定義は，target_syssvc.hまたはそこからインクルードされるファイルに
含める．

(8-2-1) LOGTASK_PRIORITY（オプション）

ログタスクの優先度を定義するマクロ．定義しない場合のデフォルト値は3．

(8-2-2) LOGTASK_STACK_SIZE（オプション）

ログタスクのスタックサイズを定義するマクロ．定義しない場合のデフォルト
値は1024．

(8-2-3) LOGTASK_PORTID（オプション）

ログタスクの出力先のシリアルポート番号．定義しない場合のデフォルト値は1．

(8-2-4) LOGTASK_INTERVAL（オプション）

ログタスクの動作間隔（単位はミリ秒）．定義しない場合のデフォルト値は10．

(8-2-5) LOGTASK_FLUSH_WAIT（オプション）

ログ出力を待ち合わせる処理において，タスクを待たせる単位となる時間（単
位はミリ秒）．定義しない場合のデフォルト値は1．

8.3 シリアルインタフェースドライバのターゲット依存部

ターゲット依存部で提供すべきシリアルインタフェースドライバのための定義
は次の通りである．これらの定義は，別に指定がない限り，target_serial.hま
たはそこからインクルードされるファイルに含め，必要なコンフィギュレーショ
ン情報をtarget_serial.cfgに記述する．関数の実体が必要な場合には，
target_serial.c等のファイルを用意する．

シリアルインタフェースドライバの中で，ターゲットのシリアルI/Oデバイスに
依存する部分を，シリアルI/Oデバイスドライバと呼ぶ．シリアルI/Oデバイス
ドライバは，おおよそ，ITRONデバイスドライバ設計ガイドラインのPDICに相当
する．PDICに相当するファイルで，他のシステムにも共通に使える可能性があ
る場合には，pdicディレクトリに置く．

8.3.1 変数，データ型，管理関数

(8-3-1-1) TNUM_PORT

シリアルインタフェースドライバがサポートするシリアルポート数を定義する
マクロ．このマクロの定義は，target_syssvc.hまたはそこからインクルードさ
れるファイルに含める．

(8-3-1-2) void sio_initialize(intptr_t exinf)（オプション）

シリアルI/Oデバイスドライバの初期化処理．target_serial.cfgに，この関数
を初期化ルーチンとして登録する静的APIを含める．

(8-3-1-3) void sio_terminate(intptr_t exinf)（オプション）

シリアルI/Oデバイスドライバの終了処理．target_serial.cfgに，この関数を
終了処理ルーチンとして登録する静的APIを含める．

(8-3-1-4) void sio_isr(intptr_t exinf)

シリアルI/Oデバイスの割込みサービスルーチン．target_serial.cfgに，この
関数を割込みサービスルーチンとして登録する静的APIを含める．また，その静
的APIに必要なシリアルI/Oデバイスの割込み番号などは，target_serial.hでマ
クロ定義する．割込みサービスルーチンではなく，割込みハンドラとすること
もできる．

(8-3-1-5) SIOPCB

シリアルI/Oポート管理ブロックのデータ型（target_serial.hには，データ型
の宣言だけ含まれていればよい）．

(8-3-1-6) SIO_RDY_SNDとSIO_RDY_RCV

送信可能コールバックの識別番号をSIO_RDY_SNDに，受信通知コールバックの識
別番号をSIO_RDY_RCVにマクロ定義する．コールバックの禁止／許可を行なうサー
ビスコール（sio_ena_cbrとsio_dis_cbr）で用いる．

8.3.2 デバイスサービスルーチン

以下のデバイスサービルルーチンは，（少なくとも）シリアルI/Oポートからの
割込みが禁止された状態で呼び出される．また，タスクコンテキスト，非タス
クコンテキストのいずれで呼び出される場合もある（いずれで呼び出されても
動作するようにしなければならない）．

(8-3-2-1) SIOPCB *sio_opn_por(ID siopid, intptr_t exinf)

siopidで指定されるシリアルI/Oポートをオープンする関数．exinfはシリアル
I/Oポートに対する拡張情報で，コールバックを呼ぶ時にポートを区別するた
めに渡す．

(8-3-2-2) void sio_cls_por(SIOPCB *siopcb)

siopcbで指定されるシリアルI/Oポートをクローズする関数．

(8-3-2-3) bool_t sio_snd_chr(SIOPCB *siopcb, char_t c)

siopcbで指定されるシリアルI/Oポートに，cで示される文字を送信する関数．
文字を送信レジスタに入れた場合にはtrueを，前に送信した文字の送信が終わっ
ていないために，文字を送信レジスタに入れられなかった場合にはfalseを返す．

(8-3-2-4) int_t sio_rcv_chr(SIOPCB *siopcb)

siopcbで指定されるシリアルI/Oポートから文字を読む関数．文字を受信してい
た場合，読んだ文字のコードは正の値として返し，文字を受信していない場合
には-1を返す．

(8-3-2-5) void sio_ena_cbr(SIOPCB *siopcb, uint_t cbrtn)

siopcbで指定されるシリアルI/Oポートからの，cbrtnで指定されるコールバッ
クを許可する．cbrtnには，SIO_RDY_SNDかSIO_RDY_RCVを指定できる．

(8-3-2-6) void sio_dis_cbr(SIOPCB *siopcb, uint_t cbrtn)

siopcbで指定されるシリアルI/Oポートからの，cbrtnで指定されるコールバッ
クを禁止する．cbrtnには，SIO_RDY_SNDかSIO_RDY_RCVを指定できる．

8.3.3 コールバックルーチン

ターゲット依存部は，必要なタイミングで，シリアルインタフェースドライバ
のターゲット非依存部に含まれる以下のコールバックルーチンを呼び出びださ
なければならない．ただし，それぞれのコールバックが禁止されている時は，
コールバックルーチンを呼び出してはならない．

コールバックルーチンは，（少なくとも）シリアルI/Oポートからの割込みが禁
止された状態で，非タスクコンテキストで呼び出す．exinfには，シリアルI/O
ポートのオープン時に指定された拡張情報を渡す．

(8-3-3-1) void sio_irdy_snd(intptr_t exinf)

送信可能コールバックルーチン．シリアルI/Oポートに対して文字が送信できる
状態になった場合に呼び出す．シリアルインタフェースドライバは，このコー
ルバックルーチンの中で，sio_snd_chrを呼び出して次の文字を送信するか，送
信すべき文字がない場合には送信可能コールバックを禁止する．

(8-3-3-2) void sio_irdy_rcv(intptr_t exinf)

受信通知コールバックルーチン．シリアルI/Oポートから文字を受信した場合に
呼び出す．シリアルインタフェースドライバは，このコールバックルーチンの
中で，必ずsio_rcv_chrを呼び出して受信した文字を取り出す．

8.4 カーネル起動メッセージの出力のターゲット依存定義

ターゲット依存部で提供すべきカーネル起動メッセージの出力のための定義は
次の通りである．

(8-4-1) TARGET_NAME

ターゲットの名称に定義する．

(8-4-2) TARGET_COPYRIGHT

カーネル起動メッセージに，ターゲット依存部の著作権表示を追加するための
マクロ．

8.5 テストプログラムのターゲット依存定義

ターゲット依存部で提供すべきサンプルプログラムおよびテストプログラムの
ための定義は次の通りである．これらの定義は，target_test.h（またはそれら
からインクルードされるファイル）に含める．

(8-5-1) STACK_SIZE（オプション）

サンプルプログラムおよびテストプログラムのタスクのスタックサイズを定義
するマクロ．定義しない場合のデフォルト値は4096．デフォルト設定ではメモ
リが不足する場合や，シミュレーション環境などで大きいスタック領域が必要
な場合には，ターゲット依存部でこのマクロを設定するスタックサイズに定義
する．

(8-5-2) CPUEXC1（オプション）

サンプルプログラムおよびテストプログラムで用いるCPU例外のCPU例外ハンド
ラ番号を定義するマクロ．このマクロを定義しない場合，CPU例外ハンドラを使
う部分がサンプルプログラムから除外される．CPU例外ハンドラのテストをする
テストプログラムはコンパイルできない．

(8-5-3) RAISE_CPU_EXCEPTION（オプション）

CPUEXC1に定義したCPU例外を発生させるC言語のプログラムを定義するマクロ．
CPUEXC1を定義した場合には必ず定義しなければならない．

(8-5-4) CANNOT_RETURN_CPUEXC（オプション）

ターゲットシステムの制約により，CPU例外ハンドラからリターンした後に，タ
スクの実行を継続できない場合に定義するマクロ．このマクロを定義すると，
CPU例外ハンドラのテストをするテストプログラムから，CPU例外ハンドラから
リターンした後の処理が除外される．サンプルプログラムの該当部分は正しく
動作しない．

(8-5-5) LOOP_REF（オプション）

サンプルプログラムにおいて，プロセッサの速度を計測するためのループ回数
を定義するマクロ．定義しない場合のデフォルト値は1000000．デフォルト設定
では，値が大き過ぎて計測に時間がかかりすぎる場合や，値が小さ過ぎて計測
結果が安定しない場合に，ターゲット依存部でこのマクロを設定するループ回
数に定義する．

(8-5-6) MEASURE_TWICE（オプション）

サンプルプログラムにおいて，プロセッサの速度を2度計測する場合に定義する
マクロ．シミュレーション環境などプロセッサの速度が変動する環境で，1度の
計測では計測結果が安定しない場合に定義する．

(8-5-7) TASK_LOOP（オプション）

サンプルプログラムにおいて，プロセッサの速度を計測せずに，タスク内での
ループ回数を固定する場合に，ループ回数を定義するマクロ．


９．その他

9.1 ドキュメント

ターゲット依存部のユーザーズマニュアルを，target_user.txtに用意する．プ
ロセッサ・チップ・開発環境依存部のユーザーズマニュアルを切り分けてもよ
いし，ファイルが大きくなる場合には複数のファイルに分割してよいが，その
場合には，target_user.txt中にそれらのファイル名を記述すること．

ターゲット依存部のユーザーズマニュアルには，少なくとも次のような内容を
記述することが望ましい．

(1) 対応しているターゲットシステムの種類・構成，バージョン番号
	・ターゲットハードウェア（ボード等）の名称と対応している構成
	・ターゲット略称
	・ターゲット非依存部のバージョン番号
	・プロセッサ，チップ，開発環境依存部の構成とバージョン番号
	・使用するPDICとバージョン番号

(2) 使用する開発環境と動作検証した条件（バージョン，オプション等）
	・言語処理系（コンパイラ，アセンブラ，リンカ等）
	・デバッグ環境

(3) ターゲット定義事項の規定

(3-1) データ型に関する規定
	・int_t型，long_t型のサイズ
	・char_t型，int_least8_t型，void *型，intptr_t型のサイズ
	・int8_t型，uint8_t型，int64_t型，uint64_t型，int128_t型，
	　uint128_t型，float32_t型，double64_t型のサポートの有無

(3-2) 割込み処理に関する規定
	・割込みハンドラ番号と割込み番号の割当て，両者の対応
	・割込み優先度の段階数（TMIN_INTPRIの値），その設定方法
	・dis_intとena_intのサポートの有無，その制限事項
	・CFG_INTの制限事項と拡張（ターゲット定義で使用できる割込み属性）
	・カーネル管理外の割込みのサポートの有無，その設定方法
	・カーネル管理外の割込みに対してDEF_INH，CFG_INTをサポートするか
	・カーネル管理外の割込みを受け付けた場合の振舞い
	・TOPPERS標準割込み処理モデルからの逸脱

(3-3) CPU例外処理に関する規定
	・CPU例外ハンドラ番号の割当て
	・xsns_xpnの制限事項

(3-4) 性能評価用システム時刻の参照に関する規定
	・get_utmのサポートの有無，その制限事項

(3-5) その他
	・その他の制限事項
	・その他の拡張機能

(4) メモリマップ
	・デフォルトのメモリマップ，その変更方法

(5) タイマドライバ関連の情報
	・タイムティックの周期，その変更方法
	・使用するリソース（タイマ）

(6) シリアルインタフェースドライバの情報
	・使用するリソース（SIOコントローラ）
	・通信パラメータ（ボーレート，ビット数，パリティの有無，ストップビット）

(7) システムログ機能の情報
	・システムログの低レベル出力の実現方法
	・通信パラメータ（ボーレート，ビット数，パリティの有無，ストップビット）

(8) システム構築手順

(9) ターゲットシステム固有の注意事項
	・タスクコンテキストに含まれるレジスタ，含まれないレジスタ

(10) 類似のターゲットにポーティングする開発者向けの参考情報

(11) ディレクトリ構成・ファイル構成

(12) バージョン履歴

また，必要に応じて，ターゲット依存部の設計メモを，target_design.txtに用
意する．プロセッサ・チップ・開発環境依存部に関する設計メモを切り分けて
もよいし，ファイルが大きくなる場合には複数のファイルに分割してもよいが，
その場合には，target_design.txt中にそれらのファイル名を記述すること．

9.2 パッケージ記述ファイル

リリースパッケージ（個別パッケージおよび簡易パッケージ）を作成するため
に，パッケージに含めるファイルを記述したパッケージ記述ファイルを用意す
る．パッケージ記述ファイルの名称は，個別パッケージ用をMANIFEST，簡易パッ
ケージ用をE_PACKAGEとする．

例えば，arch/arm_gccディレクトリに置かれたMANIFESTファイルを用いて個別
パッケージを作成する場合には，次のコマンドを実行する．

	% utils/makerelease arch/arm_gcc/MANIFEST

このコマンドにより，RELEASE/asp_arch_arm_gcc-<バージョン番号>.tar.gzが
作成される．また，target/at91skyeye_gccディレクトリに置かれたE_PACKAGE
ファイルを用いて簡易パッケージを作成する場合には，次のコマンドを実行す
る．

	% utils/makerelease target/at91skyeye_gcc/E_PACKAGE

このコマンドにより，RELEASE/asp_at91skyeye_gcc-<バージョン番号>.tar.gz
が作成される（RELEASEディレクトリがない場合には，ディレクトリが作られ
る）．

なお，makereleaseユーティリティは，ASPカーネルのソースファイルが置かれ
たディレクトリが，aspという名称であることを仮定している．また，標準の
tarコマンドがGNU tarであること（正確には，zオプションに対応していること）
を想定している．

パッケージ記述ファイルには，パッケージに含めるファイル名を，パッケージ
記述ファイルが置かれたディレクトリからの相対パス名で，1行に1つずつ記述
する．また，必要に応じて，以下のディレクティブを含める．

(a) E_PACKAGE <簡易パッケージ名>

簡易パッケージ名を指定する．簡易パッケージ記述ファイル（E_PACKAGE）の先
頭に記述する．簡易パッケージ名は，asp_<ターゲット略称>とする．例えば，
ターゲット略称がat91skyeye_gccの場合には，asp_at91skyeye_gccとなる．個
別パッケージと区別するために，簡易パッケージのファイル名には"target"を
含めない．

(b) PACKAGE <個別パッケージ名>

個別パッケージ名を指定する．個別パッケージ記述ファイル（MANIFEST）の先
頭に記述する．また，そこからインクルードされる各ファイルの先頭にも記述
し，それをインクルードしている個別パッケージ名を指定する．ターゲット依
存部の個別パッケージ名は，個別パッケージ記述ファイルが置かれたディレク
トリの相対パス中の"/"を"_"に置き換えた文字列を，"asp_"の後につなげたも
のとする．例えば，個別パッケージ記述ファイルがarch/arm_gcc/MANIFESTの場
合には，asp_arch_arm_gccとなる．

(c) VERSION <バージョン番号>

パッケージのバージョン番号を指定する．簡易パッケージ記述ファイルおよび
個別パッケージ記述ファイルの中に記述する．簡易パッケージにおいて，バー
ジョン番号をパッケージ化した日付とする場合には，パッケージ番号の代わり
に%dateと記述する．

バージョン番号の付与方法については，「TOPPERS/ASPカーネル ユーザーズマ
ニュアル」の「2.2 簡易パッケージ」および「2.3 個別パッケージ」の節を参
照すること．

(d) INCLUDE <ファイル名>

別のパッケージ記述ファイルをインクルードする．簡易パッケージ記述ファイ
ルからは，個別パッケージ記述ファイルのみをインクルードするのを原則とす
る．個別パッケージ記述ファイルからインクルードされるファイル中で指定さ
れる個別パッケージ名は，すべて一致していなければならない．


１０．リファレンス

10.1 ターゲット依存部のファイル一覧

標準的なターゲット依存部のファイル構成は次の通りである．

Makefile.target		Makefileのターゲット依存部（２章）．

target_stddef.h		TOPPERS共通定義（t_stddef.h）のターゲット依存部（３
					章）．アプリケーションとカーネルの両方からインクルー
					ドされる．
target_sil.h		システムインタフェースレイヤ（sil.h）のターゲット依
					存部（４章）．アプリケーションとカーネルの両方から
					インクルードされる．
target_kernel.h		カーネルAPI（kernel.h）のターゲット依存部（５章）．
					アプリケーションとカーネルの両方からインクルードさ
					れる．

target_config.h		カーネル実装のターゲット依存部のヘッダファイル（６
					章）．カーネルのみからインクルードされる．
target_config.c		カーネル実装のターゲット依存部のC言語で記述される
					部分（６章，オプション）．
target_support.S	カーネル実装のターゲット依存部のアセンブリ言語で記
					述される部分（６章，オプション）．
target_rename.def	カーネル実装のターゲット依存部のためのリネーム記述
					（6.12節）．
target_rename.h		target_rename.defから生成されるファイル（6.12節）．
target_unrename.h	target_rename.defから生成されるファイル（6.12節）．
target_timer.cfg	タイマドライバのシステムコンフィギュレーションファ
					イル（6.13節）．
target_timer.h		タイマドライバのヘッダファイル（6.13節）．カーネル
					のみからインクルードされる．
target_timer.c		タイマドライバの実装ファイル（6.13節，オプション）．
システム略称.h		ターゲットのハードウェア資源（割込みハンドラ番号や
					CPU例外ハンドラ番号，デバイスレジスタの番地など）の
					定義を含むヘッダファイル．アプリケーションとカーネ
					ルの両方からインクルードされる（６章，オプション）．

target_def.csv		コンフィギュレータの値取得シンボルテーブルのターゲッ
					ト依存部（７章）．
target.tf			コンフィギュレータのパス2のテンプレートファイルの
					ターゲット依存部（7.2節）．
target_check.tf		コンフィギュレータのパス3のテンプレートファイル（7.3
					節）．
target_cfg1_out.h	cfg1_out.cのリンクに必要なスタブの定義ファイル（7.4
					節）．

target_syssvc.h		システムサービスのターゲット依存定義（8.0節）．
target_serial.cfg	シリアルドライバのシステムコンフィギュレーションファ
					イル（8.3節）．
target_serial.h		シリアルドライバのヘッダファイル（8.3節）．シリアル
					ドライバのみからインクルードされる．
target_serial.c		シリアルドライバの実装ファイル（8.3節，オプション）．
target_test.h		テストプログラムのターゲット依存定義（8.4節）．

target_user.txt		ユーザーズマニュアル（9.1節）
target_design.txt	設計メモ（9.1節，オプション）
MANIFEST			個別パッケージに含めるファイルのリスト（9.2節，オプ
					ション）
E_PACKAGE			簡易パッケージに含めるファイルのリスト（9.2節，オプ
					ション）

以上
