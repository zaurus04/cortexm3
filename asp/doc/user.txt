
		TOPPERS/ASPカーネル
		ユーザーズマニュアル

		対応バージョン: Release 1.3.2
		最終更新: 2008年8月21日

このドキュメントは，TOPPERS/ASPカーネルを使用するために必要な事項を説明
するものである．

----------------------------------------------------------------------
 TOPPERS/ASP Kernel
     Toyohashi Open Platform for Embedded Real-Time Systems/
     Advanced Standard Profile Kernel

 Copyright (C) 2005-2008 by Embedded and Real-Time Systems Laboratory
             Graduate School of Information Science, Nagoya Univ., JAPAN
 
 上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
 ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
 変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
 (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
     権表示，この利用条件および下記の無保証規定が，そのままの形でソー
     スコード中に含まれていること．
 (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
     用できる形で再配布する場合には，再配布に伴うドキュメント（利用
     者マニュアルなど）に，上記の著作権表示，この利用条件および下記
     の無保証規定を掲載すること．
 (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
     用できない形で再配布する場合には，次のいずれかの条件を満たすこ
     と．
   (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
       作権表示，この利用条件および下記の無保証規定を掲載すること．
   (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
       報告すること．
 (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
     害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
     また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
     由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
     免責すること．
 
 本ソフトウェアは，無保証で提供されているものである．上記著作権者お
 よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
 に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
 アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
 の責任を負わない．
 
 @(#) $Id: user.txt 1240 2008-08-20 15:07:34Z ertl-hiro $
----------------------------------------------------------------------

○目次

１．TOPPERS/ASPカーネルの概要
	1.1 TOPPERS/ASPカーネルの位置付け
	1.2 TOPPERS/ASPカーネルの仕様
	1.3 既知の問題
２．ターゲット依存部
	2.1 ターゲット依存部の概要
	2.2 簡易パッケージ
	2.3 個別パッケージ
３．クイックスタートガイド
	3.1 開発環境の準備
	3.2 コンフィギュレータの構築
	3.3 サンプルプログラムの構築と実行
	3.4 カーネルを関数単位でライブラリ化する方法
	3.5 アプリケーションとカーネルを別々に構築する方法
４．ディレクトリ構成・ファイル構成
	4.1 配布パッケージのディレクトリ構成
	4.2 ターゲット非依存部のファイル構成
５．コンフィギュレーションスクリプトの使い方
６．Makefileの修正方法
	6.1 Makefileの変数定義
	6.2 コンパイルオプション
７．コンフィギュレータの使い方
８．システムサービス
	8.1 システムログ機能
		8.1.1 システムログ機能の位置付け
		8.1.2 ログバッファへの記録と低レベル出力
		8.1.3 ログ情報の種別
		8.1.4 ログ情報の重要度
		8.1.5 システムログ機能のサービスコール
		8.1.6 システムログ機能のためのライブラリ関数とマクロ
	8.2 シリアルインタフェースドライバ
		8.2.1 シリアルインタフェースドライバのサービスコール
		8.2.2 シリアルインタフェースドライバのその他のサービス
	8.3 システムログタスク
		8.3.1 システムログタスクのサービスコール
		8.3.2 システムログタスクのその他のサービス
	8.4 カーネル起動メッセージの出力
９．サポートライブラリ
	9.1 基本的なライブラリ関数
	9.2 システムログ出力用ライブラリ関数
	9.3 実行時間分布集計モジュール
１０．テストプログラム
	10.1 テストプログラム用ライブラリ
	10.2 カーネルの整合性検査
	10.3 機能テストプログラム
	10.4 性能評価プログラム
１１．使用上のヒント
	11.1 タイマドライバの組込み
	11.2 assertマクロの処理
	11.3 オブジェクトIDの管理
	11.4 カーネルの内部シンボルのリネーム
	11.5 トレースログ記録のサンプルコードの使用方法
１２．参考情報
	12.1 利用条件と利用報告
	12.2 保証・適用性・サポート
	12.3 バグレポート
	12.4 ウェブサイト
	12.5 TOPPERSユーザーズメーリングリスト
	12.6 TOPPERSプロジェクトのメンバ向けのサービス
	12.7 TOPPERSプロジェクトへの参加
１３．リファレンス
	13.1 サービスコール一覧
	13.2 静的API一覧
	13.3 バージョン履歴


１．TOPPERS/ASPカーネルの概要

1.1 TOPPERS/ASPカーネルの位置付け

TOPPERS/ASPカーネル（以下，ASPカーネル）は，TOPPERS新世代カーネルの基盤
（出発点）となるものとして，TOPPERSプロジェクトにおいて開発したリアルタ
イムカーネルである．μITRON4.0仕様のスタンダードプロファイル準拠のリア
ルタイムカーネルであるTOPPERS/JSPカーネルを拡張・改良する形で開発した．

1.2 TOPPERS/ASPカーネルの仕様

ASPカーネルの仕様の概要については，「TOPPERS/ASPカーネルの仕様概要」を
参照すること．また，ASPカーネルを含むTOPPERS新世代カーネルの仕様の詳細
については，別途PDFファイルの形で配布している「TOPPERS新世代カーネル統
合仕様書」（現時点では，TOPPERS/ASPカーネルに関する記述以外は未完成）を
参照すること．

1.3 既知の問題

kernel_cfg.c（およびcfg1_out.c）は，カーネル，システムサービス，アプリ
ケーションのいずれのインクルードファイルもインクルードし，いずれのシン
ボルも参照する可能性がある．そのため，カーネル，システムサービス，アプ
リケーションでシンボル等が衝突している場合や，コンパイルオプションが食
い違っている場合に，kernel_cfg.c（およびcfg1_out.c）が正しくコンパイル
できなくなる場合が考えられる．カーネルのシンボルをリネームするなどの方
法で軽減されてはいるが，問題がなくなっているわけではない．

システムコンフィギュレーションファイルから，コンフィギュレータに対する
INCLUDEディレクティブにより他のコンフィギュレーションファイルをインクルー
ドしている場合に，その中に含まれるC言語プリプロセッサのインクルードディ
レクティブ（#include）で，コンフィギュレーションファイルの置かれている
ディレクトリが，ファイルを検索するパスにはいらないという問題がある．例
えば，syssvc/syslog.cfgに「#include "syslog.h"」と記述できないのは，こ
の問題があるためである．


２．ターゲット依存部

2.1 ターゲット依存部の概要

ASPカーネルのターゲット非依存部と，各種のターゲットシステムに対応するた
めのターゲット依存部は，別々に開発されている．そのため，ASPカーネルが対
応しているすべてのターゲット依存部を，バージョンを整合させてパッケージ
化することは困難である．そこで，主に初級のユーザを対象にした簡易パッケー
ジと，上級のユーザやカーネル開発者を対象にした個別パッケージを用意して
いる．

ASPカーネルを未サポートのターゲットシステムへポーティングするために必要
な作業は，開発環境の構築と標準の開発環境との差異の吸収，カーネル自身の
ポーティング，システムサービスのポーティングなどからなる．詳しくは，
「ターゲット依存部 ポーティングガイド」を参照すること．

2.2 簡易パッケージ

簡易パッケージは，ASPカーネルが対応しているターゲットシステム毎に用意さ
れ，そのターゲットシステム上でASPカーネルを動作させるために必要なファイ
ル一式をパッケージ化したものである．簡易パッケージに含まれるファイルは，
バージョンが整合していることが確認されている．

簡易パッケージのバージョン番号は，パッケージ化した日付とすることを原則
とするが，ターゲットシステム毎の事情によりこの原則に従わない場合がある．

簡易パッケージは，基本的には，次に説明する個別パッケージを複数まとめた
ものである．そのため，対象ターゲットシステムに必要のないファイルも含ま
れている．また，簡易パッケージに含まれている個別パッケージのバージョン
は，個別パッケージのMANIFESTファイルを参照することで知ることができる．

2.3 個別パッケージ

個別パッケージは，ASPカーネルの開発単位毎に，その開発単位で開発を担当し
ているファイル一式をパッケージ化したものである．ASPカーネルのターゲット
非依存部も，一つの個別パッケージとして配布される．ある個別パッケージを
使用するためには，一般には，他の個別パッケージが必要となる．ターゲット
依存部の個別パッケージを使用するために必要となる個別パッケージとそのバー
ジョンについては，ターゲット依存部のユーザーズマニュアルを参照すること．

使用する個
別パッケージのバージョンを整合させることは，ユーザの責任である．

個別パッケージのバージョン番号は，X.Y.Zの形で表現される．ターゲット非依
存部のバージョン番号を，ASPカーネル全体のリリース番号とする．ターゲット
依存部のバージョン番号は，XとYが，それが依存するターゲット非依存部と一
致している．それに対して，Zは一致しているとは限らない．例えば，ターゲッ
ト非依存部のバージョン1.1.0に対応するターゲット依存部は，バージョン
1.1.Zの形となる．ターゲット依存部のみがバージョンアップした場合には，Z
が変更される．

使用する個別パッケージは，次の例のように，ターゲット非依存部の個別パッ
ケージを展開したのと同じディレクトリで展開する．

	% tar xvfz asp-1.1.0.tar.gz
	% tar xvfz asp_arch_arm_gcc_1.1.2.tar.gz

ターゲット非依存部の個別パッケージには，以下のターゲット依存部が含まれ
ているが，これらは他のターゲットシステムにポーティングする際の参考にす
るために用意しているものであり，その動作については未検証である．

	target/dve68k_gcc	DVE-68K/40（GNU開発環境）用ターゲット依存部
	arch/m68k_gcc		M68040（GNU開発環境）用プロセッサ依存部
	pdic/upd72001		μPD72001用 簡易SIOドライバ


３．クイックスタートガイド

ここでは，ターゲット依存部が用意されているターゲットシステム上で，ASPカー
ネル上で動作するサンプルプログラムを構築・動作させるまでの手順を示す．

3.1 開発環境の準備

ASPカーネルを用いたシステム構築には，以下のツールが必要である．

	ホストシステム用のツール（セルフ開発環境）
		C++コンパイラ，C++ライブラリ
					動作確認（Mac OS X環境）：GNU C++ 4.0.1
		Boost		動作確認：1.33.1
		perl		動作確認：5.8.6
		GNU Make	動作確認：3.80

	ターゲットシステム用のツール（クロス開発環境）
		標準規格に準拠したCコンパイラ
		アセンブラ，リンカ，ライブラリアン
		シンボルファイル出力ツール，ヘキサファイル出力ツール
		標準Cライブラリ（必須ではない）

ターゲットシステム用のツールにGNU開発環境を用いる場合には，以下のツール
が必要である．

	ターゲットシステム用のGNU開発環境ツール
		BINUTILS（as，ld，ar，nm，ranlib，objcopy，objdump）
		GCCまたはGCC-CORE（gccおよびそこから呼び出されるツール）
		NEWLIB（標準Cライブラリ，必須ではない）

動作確認されているターゲットシステム用のツールについては，ターゲット依
存部のユーザーズマニュアルを参照すること．

ホストシステム用のC++コンパイラ，C++ライブラリとBoostライブラリは，カー
ネルのコンフィギュレータの構築に必要である．コンフィギュレータをバイナ
リで入手した場合には，これらは必要ない．

ターゲットシステム用の標準Cライブラリは，アプリケーションが標準Cライブ
ラリを使用しない場合には，必要ない．ただし，コンパイラが標準Cライブラリ
関数（memcpy，memsetなど）を呼び出すコードを生成する場合があり，その場
合には標準Cライブラリが必要である．標準Cライブラリを用意する代わりに，
生成したコードが呼び出す関数のみを自分で用意してもよい．

以下では，これらのツールが用意できていることを前提に，UNIXマシン上での
構築手順を説明する．また以下の説明では，makeコマンドがGNU Makeであるも
のとする（ASPカーネルのサンプルのMakefileは，GNU Makeの拡張機能を用いて
いる）．

3.2 コンフィギュレータの構築

カーネルを構築する前に，まず，コンフィギュレータをコンパイルする必要が
ある（コンフィギュレータをバイナリで入手した場合には，このステップは必
要ない）．

コンフィギュレータ（cfgプログラム）は，cfgディレクトリに移動し，make
dependで依存関係ファイル（Makefile.depend）を生成した後，makeコマンドに
より構築される．

	% cd cfg
	% make depend
	% make

ただし，Boostをインストールしたディレクトリおよび名称が，標準で想定して
いるものとは違う場合には，Makefile中のBOOST_DIRおよびLIBBOOST_SUFFIXを
修正する必要がある（これらの変数を環境変数として定義する方法や，makeの
コマンドラインで定義する方法もある）．また，ホストシステムによっては，
最適化レベルを上げると正しくコンパイルできないことが知られている．その
ような場合には，最適化レベルを下げるか，最適化を抑止するように，
Makefileを修正する必要がある．

なお，コンフィギュレータの使用方法については，「７．コンフィギュレータ
の使い方」の章で説明する．

3.3 サンプルプログラムの構築と実行

次に，ASPカーネル上で動作するサンプルプログラムを構築する方法を説明する．

まず，サンプルプログラムのオブジェクトファイルを置くディレクトリを作成
し，コンフィギュレーションスクリプトを実行する．例えば，オブジェクトファ
イルを置くディレクトリを，ASPカーネルのソースファイルを展開したディレ
クトリの下のOBJという名称のディレクトリにする場合には，次のコマンドを
実行する（ディレクトリの場所と名称は任意に決めてよい）．

	% mkdir OBJ
	% cd OBJ
	% perl ../configure -T <ターゲット略称>

ここで，<ターゲット略称>は，targetディレクトリの下に置かれているターゲッ
ト依存部ディレクトリの名称である．コンフィギュレーションスクリプトのオ
プションについては，「５．コンフィギュレーションスクリプトの使い方」の
章で説明する．

コンフィギュレーションスクリプトの実行により，カレントディレクトリには，
サンプルプログラムを構築するためのMakefile，サンプルプログラム用のコン
フィギュレーションファイル（sample1.cfg），サンプルプログラム本体
（sample1.hおよびsample1.c）が生成される．

コンフィギュレーションスクリプトの実行後，必要であればMakefileを修正す
る．Makefileの修正方法については，「６．Makefileの修正方法」の章で説明
する．

その後，make dependで依存関係ファイル（Makefile.depend）を生成した後，
makeコマンドによりサンプルプログラムのロードモジュール（aspまたは
asp.exe）が生成できる．依存関係ファイルの生成には若干時間がかかる．

	% make depend
	% make

ここで構築したサンプルプログラム（sample1.h，sample1.c，sample1.cfg）
は，ASPカーネルの基本的な動作を確認するためのものである．このプログラ
ムの概要説明は，sample1.cの先頭のコメントにある．

3.4 カーネルを関数単位でライブラリ化する方法

前節の手順では，カーネルをファイル単位でコンパイルし，ライブラリ化して
いたが，カーネルのコードサイズを縮小するためには，使用しないサービスコー
ルはリンクしない方が望ましい．そこでASPカーネルでは，カーネルを関数単位
でコンパイルし，ライブラリ化する方法を用意している．

この方法でサンプルプログラムを構築するには，コンフィギュレーションスク
リプトに，それを指示するオプション（-f）を付加するだけでよい．

	% mkdir OBJ_LIB
	% cd OBJ_LIB
	% perl ../configure -T <ターゲット略称> -f

ここで，OBJ_LIBというディレクトリの場所と名称は，任意に決めてよい．これ
以降の手順は，前節と同じである．

3.5 アプリケーションとカーネルを別々に構築する方法

前節で説明した方法では，アプリケーションとカーネルを同時に生成するため，
オブジェクトファイルを置くディレクトリに非常に多くのファイルが作成され
て，扱いにくくなる．そこで，カーネルを修正する頻度が低い場合には，カー
ネルは事前に構築しておき，後でアプリケーションだけを構築する方法を用意
している．以下では，サンプルプログラムを構築を例に，その手順について説
明する．

まず，カーネルを構築するディレクトリを作成し，コンフィギュレーションス
クリプトを実行する．例えば，カーネルを構築するディレクトリを，ASPカー
ネルのソースファイルを展開したディレクトリの下のkernel_libという名称の
ディレクトリにする場合には，次のコマンドを実行する（ディレクトリの場所
と名称は任意に決めてよい）．

	% mkdir KERNEL_LIB
	% cd KERNEL_LIB
	% perl ../configure -T <ターゲット略称> -f

これにより，カーネルを構築するディレクトリに，Makefile，sample1.cfg，
sample1.h，sample1.cが生成されるが，Makefile以外は実質的には使用しない．

make dependで依存関係ファイル（Makefile.depend）を生成した後，make
libkernel.aによりカーネルライブラリ（libkernel.a）が生成できる．

	% make depend
	% make libkernel.a

次に，アプリケーションを構築するディレクトリを作成し，コンフィギュレー
ションスクリプトを実行する．例えば，アプリケーションを構築するディレク
トリを，ASPカーネルのソースファイルを展開したディレクトリの下のAPLとい
う名称のディレクトリにする場合には，次のコマンドを実行する（ディレクト
リの場所と名称は任意に決めてよい）．

	% cd ..
	% mkdir APL
	% cd APL
	% perl ../configure -T <ターゲット略称> -L ../KERNEL_LIB

ここで-Lオプションには，カーネルを構築したディレクトリのパスを指定する．

最後に，make dependで依存関係ファイル（Makefile.depend）を生成した後，
makeコマンドによりサンプルプログラムのロードモジュール（aspまたは
asp.exe）が生成できる．

	% make depend
	% make

この手順では，アプリケーション構築時にはカーネルの再構築が必要かチェッ
クしないため，カーネルのソースコードを修正した場合には，カーネルを構築
したディレクトリでmake libkernel.aを再実行する必要がある．

以上では，カーネルとアプリケーションを別々のディレクトリで構築したが，
-Lオプションにカレントディレクトリ（ただし，"."という記述では不可）を指
定することで，カーネルとアプリケーションを同じディレクトリで別々に構築
することもできる．具体的には，次の手順となる．

	% mkdir OBJ
	% cd OBJ
	% perl ../configure -T <ターゲット略称> -L ../OBJ
	% make depend
	% make libkernel.a
	% make cleankernel
	% make

ここで，make cleankernelは，カーネルライブラリを生成するための中間ファ
イルを削除するものである．この手順では，make dependによりカーネルライ
ブラリに関する依存関係を生成しないため，カーネルのソースコードを修正し
た場合には，必ずmake cleankernel（または，make clean）してから，make
libkernel.aする必要があるので注意すること．


４．ディレクトリ構成・ファイル構成

4.1 配布パッケージのディレクトリ構成

	include/		アプリケーション向けヘッダファイル
	kernel/			カーネルソースファイル
	syssvc/			システムサービスヘッダファイル，ソースファイル
	library/		サポートライブラリソースファイル
	target/			ターゲット依存部
	arch/			ターゲット依存部の共通部分
		gcc/		GCC開発環境依存部
		logtrace/	トレースログ記録のサンプルコード
	pdic/			PDIC（デバイスドライバのOS非依存部分）
	cfg/			コンフィギュレータ
	utils/			ユーティリティプログラム
	sample/			サンプルプログラムとMakefile
	doc/			ドキュメント
	test/			テストプログラム
	extension/		拡張パッケージ

4.2 ターゲット非依存部のファイル構成

ターゲット非依存部（カーネルコンフィギュレータとテストプログラムは除く）
の各ファイルの概要は次の通り．

	README.txt			TOPPERS/ASPカーネルの簡単な紹介
	configure			コンフィギュレーションスクリプト（GNU開発環境用）
	MANIFEST			個別パッケージのファイルリスト

	include/
		kernel.h		ASPカーネルを使用するための定義
		sil.h			システムインタフェースレイヤを使用するための定義
		t_stddef.h		TOPPERS共通ヘッダファイル
		itron.h			ITRON仕様共通規定のデータ型・定数・マクロ
		t_syslog.h		システムログ出力を行うための定義
		t_stdlib.h		基本的なライブラリ関数を使用するための定義
		queue.h			キュー操作ライブラリを使用するための定義
		histogram.h		実行時間分布集計モジュールを使用するための定義
		log_output.h	システムログのフォーマット出力を使用するための定義

	kernel/
		Makefile.kernel		カーネルのファイル構成の定義
		kernel_impl.h		カーネル実装用標準ヘッダファイル
		kernel_int.h		kernel_cfg.c用のヘッダファイル
		kernel_rename.def	カーネルの内部識別名のリネーム定義
		kernel_rename.h		カーネルの内部識別名のリネーム
		kernel_unrename.h	カーネルの内部識別名のリネーム解除	
		kernel_api.csv		コンフィギュレータの静的APIテーブル
		kernel_def.csv		コンフィギュレータの値取得シンボルテーブル
		kernel.tf			コンフィギュレータのパス2のテンプレートファイル
		kernel_check.tf		コンフィギュレータのパス3のテンプレートファイル
		allfunc.h		すべての関数をコンパイルするための定義
		check.h			エラーチェック用マクロ
		startup.c		カーネルの初期化と終了処理
		task.h			タスク操作ルーチン関連の定義
		task.c			タスク操作ルーチン
		wait.h			待ち状態操作ルーチン関連の定義
		wait.c			待ち状態操作ルーチン
		time_event.h	タイムイベント管理関連の定義
		time_event.c	タイムイベント管理
		task_manage.c	タスク管理機能
		task_refer.c	タスク状態参照機能
		task_sync.c		タスク付属同期機能
		task_except.c	タスク例外処理機能
		semaphore.h		セマフォ機能関連の定義
		semaphore.c		セマフォ機能
		eventflag.h		イベントフラグ機能関連の定義
		eventflag.c		イベントフラグ機能
		dataqueue.h		データキュー機能関連の定義
		dataqueue.c		データキュー機能
		pridataq.h		優先度データキュー機能関連の定義
		pridataq.c		優先度データキュー機能
		mailbox.h		メールボックス機能関連の定義
		mailbox.c		メールボックス機能
		mempfix.h		固定長メモリプール機能関連の定義
		mempfix.c		固定長メモリプール機能
		time_manage.c	システム時刻管理機能
		cyclic.h		周期ハンドラ機能関連の定義
		cyclic.c		周期ハンドラ機能
		alarm.h			アラームハンドラ機能関連の定義
		alarm.c			アラームハンドラ機能
		sys_manage.c	システム状態管理機能
		interrupt.h		割込み管理機能関連の定義
		interrupt.c		割込み管理機能
		exception.h		CPU例外管理機能関連の定義
		exception.c		CPU例外管理機能

	syssvc/
		banner.h		カーネル起動メッセージの出力のための定義
		banner.c		カーネル起動メッセージの出力
		banner.cfg		カーネル起動メッセージの出力のコンフィギュレー
						ションファイル
		logtask.h		システムログタスクを使用するための定義
		logtask.c		システムログタスク
		logtask.cfg		システムログタスクのコンフィギュレーションファイル
		serial.h		シリアルインタフェースドライバを使用するための定義
		serial.c		シリアルインタフェースドライバ
		serial.cfg		シリアルドライバのコンフィギュレーションファイル
		syslog.h		システムログ機能を使用するための定義
		syslog.c		システムログ機能
		syslog.cfg		システムログ機能のコンフィギュレーションファイル
		vasyslog.c		可変数引数のシステムログライブラリ

	library/
		histogram.c		実行時間分布集計モジュール
		log_output.c	システムログのフォーマット出力
		strerror.c		エラーメッセージ文字列を返す関数
		t_perror.c		エラーメッセージの出力

	arch/gcc/
		MANIFEST		個別パッケージのファイルリスト
		tool_stddef.h	t_stddef.hの開発環境依存部（GCC用）

	arch/logtrace/
		MANIFEST		個別パッケージのファイルリスト
		trace_config.h	トレースログに関する設定
		trace_config.c	トレースログ機能
		trace_dump.c	トレースログのダンプ

	utils/
		applyrename		ファイルにリネームを適用
		genoffset		offset.hの生成（GNU開発環境用）
		genrename		リネームヘッダファイルの生成
		gentest			テストプログラムの生成
		makedep			依存関係リストの生成（GNU開発環境用）
		makerelease		リリースパッケージの生成

	sample/
		Makefile		サンプルのMakefile（GNU開発環境用）
		sample1.h		サンプルプログラム(1)に関する定義
		sample1.c		サンプルプログラム(1)
		sample1.cfg		サンプルプログラム(1)のコンフィギュレーションファイル

	doc/
		user.txt			ユーザーズマニュアル
		asp_spec.txt		TOPPERS/ASPカーネルの仕様概要
		extension.txt		機能拡張・チューニングガイド
		migration.txt		TOPPERS新世代カーネルへのマイグレーションガイド
		porting.txt			ターゲット依存部 ポーティングガイド
		configurator.txt	コンフィギュレータ仕様
		design.txt			設計メモ
		version.txt			変更履歴


５．コンフィギュレーションスクリプトの使い方

コンフィギュレーションスクリプト（configure）は，ASPカーネルおよびアプ
リケーションプログラムを構築するために必要な基本的なコンフィギュレーショ
ンを行うためのプログラムである．

ASPカーネルを用いてアプリケーションを作成する場合には，まずオブジェクト
ファイルを置くディレクトリを作成し，そのディレクトリでコンフィギュレー
ションスクリプトを実行する．オブジェクトファイルを置くディレクトリの場
所と名称は，任意に決めてよい．

コンフィギュレーションスクリプトに対するオプションは次の通り．

	-T <ターゲット略称>
		ターゲットシステムの名称を，targetディレクトリの下に置かれてい
		るターゲット依存部ディレクトリの名称で指定する（必須）．

	-A <アプリケーションプログラム名>
		アプリケーションプログラムの名称を指定する．省略した場合には，
		サンプルプログラム（sample1）となる．

	-a <アプリケーションのディレクトリ名>
		アプリケーションプログラムのソースファイル（システムコンフィギュ
		レーションファイルを除く）を置いたディレクトリ名を指定する．省
		略した場合には，オブジェクトファイルを置くディレクトリに置かれ
		ていることを仮定する．システムコンフィギュレーションファイルは，
		オブジェクトファイルを置くディレクトリに置くこと．

	-U <オブジェクトファイル名>
		アプリケーションプログラムのメインのオブジェクトファイル（-A 
		で指定したアプリケーションプログラム名に".o"を付加したもの）以
		外に，リンクすべきオブジェクトファイルの名称を，".o"を付加した
		形で指定する．""で囲むことによって，複数のファイルを指定するこ
		とも可能である（-Uオプションを複数使ってはならない）．

	-L <カーネルライブラリのディレクトリ名>
		事前に構築したカーネルライブラリ（libkernel.a）を用いて，アプリ
		ケーションのみを構築する場合には，このオプションにカーネルライ
		ブラリの置かれたディレクトリ名を指定する．このオプションの使用
		例については，「3.5 アプリケーションとカーネルを別々に構築する
		方法」の節を参照すること．

	-f
		カーネルを関数単位でコンパイルしライブラリ化する場合に，このオ
		プションを指定する．このオプションの使用例については，「3.4 カー
		ネルを関数単位でライブラリ化する方法」の節を参照すること．

	-D <ASPカーネルのソースディレクトリ名>
		ASPカーネルのソースファイルを置いたディレクトリ名を指定する．省
		略した場合には，configureの置かれているディレクトリとなる．

	-l <プログラミング言語>
		アプリケーションプログラムのプログラミング言語を指定する．現時
		点では，cとc++のみをサポートしている．

	-t <テンプレートディレクトリ名>
		Makefileやサンプルプログラムのテンプレートの置かれたディレクト
		リ名を指定する．省略した場合には，sampleディレクトリとなる．

	-d <実行環境名>
		ターゲットシステム上でのプログラムの実行環境（ないしは，デバッ
		グ環境）の名称を指定する．このオプションを指定すると，実行環境
		を指定するシンボル（TOPPERS_<デバッグ環境名>）がマクロ定義され
		る．省略した場合には，実行環境を指定するシンボルはマクロ定義さ
		れない．

	-r
		トレースログ記録のサンプルコードを有効にする場合に，このオプショ
		ンを指定する．このオプションの使用例については，「11.5 トレース
		ログ記録のサンプルコードの使用方法」の節を参照すること．

	-p <perlのパス名>
		perlのパス名を指定する．省略した場合には，/usr/local/binと
		/usr/binを探索し，perlのパス名を決定する．

	-g <コンフィギュレータのパス名>
		コンフィギュレータ（cfg）のパス名を指定する．省略した場合には，
		デフォルトのパス名（ASPカーネルのソースディレクトリの下の
		cfg/cfg/cfg）となる．

コンフィギュレーションスクリプトが行う処理は次の通りである．

(1) Makefileの生成

テンプレートディレクトリ（デフォルトでは，sample）から適切なMakefileを
選択し，必要な箇所を書き換えて，Makefileを生成する．

(2) サンプルプログラムの生成

指定したアプリケーションプログラムがテンプレートディレクトリにある場合，
適切なアプリケーションプログラムのソースファイルを選択し，必要な箇所を
書き換えて，アプリケーションプログラムのソースファイル（例えば，
sample1.h，sample1.c，sample1.cfg）を生成する．

(3) コンフィギュレータが構築できているかのチェック

コンフィギュレータ（cfg）のファイルがあるかチェックし，ファイルがない場
合には，コンフィギュレータの構築を促すメッセージを出力する．


６．Makefileの修正方法

前の章で説明したように，コンフィギュレーションスクリプトに与えるオプショ
ン等からMakefileが生成されるが，コンフィギュレーションスクリプトで対応
できない場合には，Makefileを直接修正する必要がある．ここでは，Makefile
の中で，修正が必要となる可能性の高い箇所について説明する．

なお，Makefileを修正した後にコンフィギュレーションスクリプトを再実行す
ると，修正したMakefileが上書きされてしまうので注意すること（古いものが
Makefile.bakに保存される）．

6.1 Makefileの変数定義

(A) ターゲット略称

TARGETには，ターゲットシステムの名称を，targetディレクトリの下に置かれ
ているターゲット依存部ディレクトリの名称で指定する．この定義は，通常は，
コンフィギュレーションスクリプトに対する-Tオプションにより行う．

(B) オブジェクトファイルの拡張子

Cygwin環境でコンパイルする時には，OBJEXTを"exe"に定義する必要がある．こ
れは，Cygwin環境では，ロードモジュールのファイル名に拡張子".exe"が付加
されるのに対応するためのものである．Cygwin環境であることを判定できれば，
コンフィギュレーションスクリプトがこの定義を行う．

(C) 実行環境（ターゲット依存）

ターゲットによっては，実行環境に対応してターゲット依存部のコードを差し
換える場合がある．これを可能にするために，実行環境の名称をDBGENVに定義
している．この定義は，通常は，コンフィギュレーションスクリプトに対す
る-Dオプションにより行う．どのターゲットがどの実行環境に対応しているか
は，ターゲット依存部のユーザーズマニュアルを参照すること．

(D) カーネルライブラリのディレクトリ名

KERNEL_LIBには，カーネルライブラリの置かれたディレクトリ名を定義する．
この定義は，通常は，コンフィギュレーションスクリプトに対する-Lオプショ
ンにより行う．

(E) カーネルを関数単位でコンパイルするかどうか

KERNEL_FUNCOBJSは，カーネルを関数単位でコンパイルする場合にはtrueに定義
し，ファイル単位でコンパイルする場合には未定義とする．この定義は，通常
は，コンフィギュレーションスクリプトに対する-fオプションにより行う．

(F) 共通コンパイルオプション

すべてのプログラムに共通するコンパイルオプションの追加が必要な場合には，
下の変数の定義を変更する．そのコンパイルオプションが，特定のターゲット
で常に必要な場合には，ターゲット依存の定義を入れたMakefile.target等を修
正すべきである．

	CDEFS		コンパイラに対する-Dオプションを記述する．
	INCLUDES	コンパイラに対する-Iオプションを記述する．
	COPTS		コンパイラに対するその他のオプションを記述する．
	LDFLAGS		リンカに対するオプションを記述する．
	LIBS		ライブラリリンクのためのオプションを記述する．

追加の可能性のあるコンパイルオプションについては，「6.2 コンパイルオプ
ション」の節を参照のこと．

(G) アプリケーションプログラム名

APPLNAMEには，アプリケーションプログラム名を定義する．システムコンフィ
ギュレーションファイル名は，APPLNAMEに定義した名前に拡張子".cfg"を付加
した名前とする．また，アプリケーションのメインファイルは，APPLNAMEに定
義した名前に拡張子".c"を付加した名前とする．この定義は，通常は，コンフィ
ギュレーションスクリプトに対する-Aオプションにより行う．

(H) アプリケーションのディレクトリ名

アプリケーションのソースファイルを，オブジェクトファイルを置くのとは別
のディレクトリに置く場合には，APPLDIRにそのディレクトリ名を定義する．こ
の定義は，通常は，コンフィギュレーションスクリプトに対する-aオプション
により行う．アプリケーションのソースファイルを置くディレクトリが複数あ
る場合には，APPL_DIRの定義を変更することで対応する．

(I) アプリケーションのプログラムファイル名

アプリケーションが複数のソースファイルで構成される場合には，そのオブジェ
クトファイル名を，APPL_ASMOBJS，APPL_COBJS，APPL_CXXOBJSに列挙する．

(J) アプリケーションのコンパイルオプション

アプリケーションのコンパイルに必要なコンパイルオプションや，アプリケー
ションがライブラリを必要とする場合には，APPL_CFLAGSおよびAPPL_LIBSに定
義する．

(K) ロードモジュールのファイル名

標準のロードモジュールのファイル名をOBJNAMEに定義する．デフォルトはasp
である．

(L) ターゲットファイルの定義

ターゲット"all"の依存ファイルとしてに，ロードモジュールの形式を指定する．
具体的には，ELF形式の時は$(OBJFILE)，バイナリ形式の時は$(OBJNAME).bin，
モトローラ S形式の時は$(OBJNAME).srecを指定する．$(OBJFILE)は，Cygwin
環境でOBJEXTを"exe"に定義した時には$(OBJNAME).exe，そうでない場合には
$(OBJNAME)となる．

6.2 コンパイルオプション

ASPカーネルのコード中には，assertマクロが使われている．assertマクロは，
NDEBUGを定義することで，オブジェクトコード中から消すことができる．カー
ネルのデバッグが終了すれば，-DNDEBUGを指定してコンパイルした方が効率が
よくなる．

ターゲット依存部において，コンパイルオプションに-Werror（警告をエラー扱
いする）を指定している場合がある．そのようなターゲットにおいて，アプリ
ケーションで警告が避けられない場合には，ターゲット依存部を修正してコン
パイルオプションを削除する必要がある．

また，TOPPERS_OMIT_SYSLOGを定義してコンパイルすることで，システムログ出
力を抑止することができる．


７．コンフィギュレータの使い方

コンフィギュレータ（cfg）は，TOPPERS新世代カーネル統合仕様書の2.12.5節
の記述の通り，3つのパスで構成される．

コンフィギュレータは，システムコンフィギュレーションファイル名をパラメー
タに取り，以下のオプションを持つ（重要なもののみ）．

	--help
		オプションのリストと説明を表示する．

	-v［--version］
		コンフィギュレータのバージョンを表示する．

	-k［--kernel］<カーネル名>
		カーネルの名称を指定する．デフォルトはasp．

	-p［--pass］<パス番号>
		パス番号を指定する．1〜3のいずれか．

	-I［--include-path］<インクルードパス名>
		INCLUDEディレクティブにおいて，インクルードするコンフィギュレー
		ションファイルを探すパス名を指定する．

	-T［--template-file］<テンプレートファイル名>
		テンプレートファイルの名称を指定する．パス2とパス3で有効．

	--api-table <静的APIテーブルファイル名>
		静的APIテーブルのファイル名を指定する．

	--cfg1-def-table <値取得シンボルテーブルファイル名>
		値取得シンボルテーブルのファイル名を指定する．

	-r［--rom-image］<ロードモジュール名>
		ロードモジュールをSレコードフォーマットの形に変換したファイルの
		名称を指定する．パス3でのみ有効．

	-s [--symbol-table] <シンボルファイル名>
		ロードモジュール中の各シンボルとアドレスの対応表を含むシンボル
		ファイルの名称を指定する．パス3でのみ有効．

	--id-output-file <ID番号出力ファイル名>
		オブジェクトのID番号の割付け結果を，指定した名前のファイルに書
		き出す．パス2でのみ有効．

	--id-input-file <ID番号入力ファイル名>
		オブジェクトのID番号の割付けを，指定した名前のファイルから取り
		込む．パス2でのみ有効．

	--external-id
		オブジェクトのID番号を保持する変数の定義を生成する．パス2でのみ
		有効．

	-M［--print-dependencies］<ターゲットシンボル>
		システムコンフィギュレーションファイルの依存関係を出力する．
		Makefile中の依存関係を生成する際に用いる．

コンフィギュレータの詳細仕様については，別途PDFファイルの形で配布してい
る「TOPPERS新世代カーネル用コンフィギュレータ仕様」を参照すること．


８．システムサービス

8.1 システムログ機能

システムログ機能は，カーネル内で発生した異常事象やカーネルのトレースロ
グ，システムサービスやアプリケーションで発生した異常事象やトレースログ
を，ログ情報として記録するための機能である．また，記録したログ情報を取
り出す機能も持つ．

システムログ機能は，システムコンフィギュレーションファイルでsyslog.cfg
をインクルードすることで，システムに組み込むことができる．システムログ
出力を行うソースファイルでは，t_syslog.hをインクルードする．また，シス
テムログ機能のその他のサービスコールを呼び出すソースファイルでは，
syslog.hをインクルードする．

8.1.1 システムログ機能の位置付け

システムログ機能は，カーネル内からも呼び出すことができるため，カーネル
より下の階層のモジュールと位置付けることができる．この意味では，他のシ
ステムサービスとは位置付けが異なる．

一方，ログ情報をシステム外部に出力するためには，シリアルインタフェース
ドライバなど，カーネル上で動作するシステムサービスを用いる必要がある．
そこで，ログ情報をシステム外部に出力するためのサービス（これを，システ
ムログタスクと呼ぶ）は，システムログ機能とは分離して実装することとし，
システムログ機能はログ情報の記録・取出しのための機能に絞っている．

以上のように，システムログ機能はカーネルより下の階層のモジュールである
が，システムログ機能の中でログ時刻を取り出すために，カーネルの機能を必
要とする．実装上は，カーネルの内部変数を直接参照している．そのため，カー
ネルの実行開始前や終了後は，ログ時刻は正しく記録されない．

8.1.2 ログバッファへの記録と低レベル出力

上述したように，ログ情報をシステムの外部に出力するためには，カーネル上
で動作するシステムサービスを用いる必要があるため，カーネルの動作を継続
できないような重大な異常事象が起こった場合には，ログ情報を出力できなく
なる．また，これらのシステムサービス自身をデバッグする場合にも，ログ情
報の出力ができない．

そこで，カーネル上で動作するシステムサービスが使えない場合にでもログ情
報を出力するために，低レベル出力機能を用意する．低レベル出力機能は，ター
ゲット依存に用意する低レベルの文字出力関数（target_fput_log）を用いてロ
グ情報を出力する機能である．低レベルの文字出力関数は，ターゲット依存部
で用意することとしているが，最終製品に組み込まれる場合などでは，文字を
出力する方法がない状況も考えられる．そのような場合，低レベルの文字出力
関数に送られた文字は，メモリ上に残しておくか，捨ててしまうしかない．

ログ情報を，ログバッファへ記録するか低レベル出力機能を用いて出力するか
の設定は，システムログ機能のサービスコール（syslog_msk_log）によって行
うことができる．syslog_msk_logの使い方については後述する．

低レベル出力機能を用いると，ログメッセージの作成処理（printf相当の処理）
と低レベルの文字出力処理をカーネル内で行うために，カーネルの応答性が悪
くなることに注意しなければならない．特に，低レベルの文字出力処理はデバ
イスをポーリングする形で実装するのが通常で，その場合には，カーネルの応
答性は実用的と言えない程に悪くなる．

8.1.3 ログ情報の種別

システムログ機能は，ログ情報に以下の種別を設けている．

		LOG_TYPE_COMMENT	コメント
		LOG_TYPE_ASSERT		アサーションの失敗
		LOG_TYPE_INH		割込みハンドラ
		LOG_TYPE_ISR		割込みサービスルーチン
		LOG_TYPE_CYC		周期ハンドラ
		LOG_TYPE_ALM		アラームハンドラ
		LOG_TYPE_OVR		オーバランハンドラ
		LOG_TYPE_EXC		CPU例外ハンドラ
		LOG_TYPE_TEX		タスク例外処理ルーチン
		LOG_TYPE_TSKSTAT	タスク状態変化
		LOG_TYPE_DSP		ディスパッチャ
		LOG_TYPE_SVC		サービスコール

ログ情報の種別の中で，LOG_TYPE_COMMENTとLOG_TYPE_ASSERT以外は，カーネル
のトレースログに用いるためのものであるが，使用するかどうかはターゲット
依存部に任されている．

8.1.4 ログ情報の重要度

システムログ機能は，ログ情報を出力する際に指定する重要度に基づいて，実
際に出力するログ情報を動的に設定することができる．これは，UNIXのシステ
ムログ機能をまねたもので，ログの重要度の種類や指定方法もUNIXのAPIを参考
にしている．また，低レベル出力機能を用いて出力するログ情報も，重要度に
基づいて動的に設定することができる．

具体的には，ログの重要度として次の8段階を用意している．

		LOG_EMERG		カーネルの動作を継続できないエラー
		LOG_ALERT
		LOG_CRIT
		LOG_ERROR		重要性の低いシステムエラー
		LOG_WARNING		警告メッセージ．システムは安全に継続動作できる
		LOG_NOTICE
		LOG_INFO
		LOG_DEBUG		デバッグのためのメッセージ

どの重要度のログ情報をログバッファに記録するかと，どの重要度のログ情報
を低レベル出力機能を用いて出力するかは，システムログ機能のサービスコー
ル（syslog_msk_log）によって設定することができる．

8.1.5 システムログ機能のサービスコール

システムログ機能の提供するサービスコールは次の通りである．これらのサー
ビスコールを呼び出すソースファイルでは，syslog.hをインクルードする必要
がある．

(1) ER syslog_wri_log(uint_t prio, const SYSLOG *p_syslog)

システムログ機能に，重要度prioでログ情報を出力する（ログバッファへ記録
するか低レベル出力機能を用いて出力する）．SYSLOGは，ログ情報を格納する
ためのデータ型（構造体）で，このサービスコールにはログ情報を格納した領
域へのポインタを渡す．

プロトタイプ宣言において，*p_syslogにconst指定がされているが，実際には，
この関数の中で，*p_syslogのlogtimフィールドにシステム時刻を書き込んでい
る．

(2) ER_UINT syslog_rea_log(SYSLOG *p_syslog)

ログバッファからログ情報を1つ取り出す．ログバッファが空の時はE_OBJ，そ
うでない場合は，ログバッファのオーバフローにより失われたログ情報の数
（ログ情報が失われていない場合は0）を返す．システムログタスクが用いるこ
とを想定している．

(3) ER syslog_msk_log(uint_t logmask, uint_t lowmask)

ログバッファに記録すべきログ情報の重要度の示すビットマップ（logmask）と，
低レベル出力機能を用いて出力すべきログ情報の重要度を示すビットマップ
（lowmask）を設定する．ビットマップを作るためのマクロとして，LOG_MASKと
LOG_UPTOを用意している．

(4) ER_UINT syslog_ref_log(T_RLOG *pk_rlog)

システムログ機能の状態を参照する．具体的には，ログバッファに記録されて
いるログ情報の数，ログバッファのオーバフローにより失われたログ情報の数，
ログバッファに記録すべきログ情報の重要度の示すビットマップ，低レベル出
力機能を用いて出力すべきログ情報の重要度を示すビットマップを参照するこ
とができる．

8.1.6 システムログ機能のためのライブラリ関数とマクロ

システムログ出力のためのライブラリ関数とマクロは次の通りである．これら
だけを呼び出すソースファイルでは，t_syslog.hをインクルードすればよい．

(1) void _syslog_n(uint_t prio, uint_t type, intptr_t arg1, ..., intptr_t argn)
    ※ nは0〜6のいずれか．

ログ種別がtype，パラメータがarg1〜argnのログ情報を，重要度prioで出力す
るための関数．

(2) void syslog_n(uint_t prio, const char *format, arg1, ..., argn)
    ※ nは0〜5のいずれか．

format文字列およびそれに続く引数から作成されるメッセージを，ログ種別が
LOG_TYPE_COMMENTのログ情報として，重要度prioで出力するためのマクロ．

formatはメッセージのフォーマット記述，arg1〜argnはフォーマット記述中で
参照される値で，printfのフォーマット記述のサブセットとなっている．arg1〜
argnは，このマクロ中でintptr_t型にキャストされるため，intptr_t型に型変
換できる任意の型を渡すことができ，型チェックはされない．formatおよび
arg1〜argnには，次の制限がある．

・formatのフォーマット記述は，定数文字列を渡すことを想定しており，この
マクロ処理を終えた後も変化してはならない．

・format中に使えるフォーマット指定は次の通り．

	%d		引数をint_t型とみなし，10進数で表示
	%u		引数をuint_t型とみなし，10進数で表示
	%x		引数をuint_t型とみなし，16進数（英文字は小文字）で表示
	%X		引数をuint_t型とみなし，16進数（英文字は大文字）で表示
	%p		引数をポインタとみなし，16進数（英文字は小文字）で表示
	%c		引数を文字コードとみなし，文字を表示
	%s		引数を文字列を示すポインタとみなし，文字列を表示
	%%		'%'を表示（引数は取らない）

%d, %u, %x, %Xにおいては，'%'の直後に表示桁数を指定する10進数値を記述す
ることができる．その場合，表示すべき文字列が指定した桁数に満たない場合
には，指定した桁数内に右詰めで表示する．10進数値が'0'で始まる場合には，
その間に'0'を埋める．

また，intptr_t型のサイズがlong型のサイズ以上である環境においては，次の
フォーマット指定も使用することができる．この他のフォーマット指定に'l'
を付加した場合には無視する（%lcと%lsには対応していない）．

	%ld		引数をlong_t型とみなし，10進数で表示
	%lu		引数をulong_t型とみなし，10進数で表示
	%lx		引数をulong_t型とみなし，16進数（英文字は小文字）で表示
	%lX		引数をulong_t型とみなし，16進数（英文字は大文字）で表示

・arg1〜argnにポインタを渡す場合（%sに対応する引数の場合）に，ポインタ
の指すデータは，このマクロ処理を終えた後も変化してはならない．定数文字
列を渡すことを想定している．

(3) void syslog(uint_t prio, const char *format, ...)

format文字列およびそれに続く引数から作成されるメッセージを，ログ種別が
LOG_TYPE_COMMENTのログ情報として，重要度prioで出力するための関数で，引
数の数を可変にしたもの．formatに続く引数は最大5個まで．formatおよびそれ
に続く引数には，syslog_nと同様の制限がある．

このライブラリ関数は，可変数引数を処理するために内部で文字列をスキャン
する．そのため，実行時間が長くなる可能性があり，割込み禁止状態で呼び出
すべきではない．主にアプリケーションプログラムが用いることを想定してい
る．

(4) UINT LOG_MASK(UINT prio)

重要度prioのみセットされたビットマップを作るマクロ．syslog_msk_logに渡
す引数を作るために用いる．

(5) UINT LOG_UPTO(UINT prio)

重要度prio以上の重要度がすべてセットされたビットマップを作るマクロ．
syslog_msk_logに渡す引数を作るために用いる．

8.1.7 システムログ機能のその他のサービス

システムログ機能は，前記のサービスコール等に加えて，初期化処理のための
関数を持つ．

(1) void syslog_initialize(intptr_t exinf)

システムログ機能を初期化する．syslog.cfgによって，カーネルに初期化ルー
チンとして登録される．exinfは無視される．

8.2 シリアルインタフェースドライバ

シリアルインタフェースドライバは，シリアルポートを扱うためのドライバで
ある．

シリアルインタフェースドライバは，システムコンフィギュレーションファイ
ルでserial.cfgをインクルードすることで，システムに組み込むことができる．
シリアルインタフェースドライバを呼び出すソースファイルでは，serial.hを
インクルードする．

シリアルインタフェースドライバは，ポート毎にセマフォを2個ずつ使用する．
セマフォを生成する静的APIは，serial.cfgに含まれている．

8.2.1 シリアルインタフェースドライバのサービスコール

シリアルインタフェースドライバを呼び出すサービスコールの仕様は次の通り
である．この中で，シリアルポートのID番号（portid）の解釈はターゲット依
存となる．

これらのサービスコールは，非タスクコンテキストから呼び出すことはできな
い．また，serial_rea_datとserial_wri_datは，ディスパッチ保留状態で呼び
出すことはできない．いずれも，呼び出した場合にはE_CTXエラーとなる．

(1) ER serial_opn_por(ID portid)

portidで指定されたシリアルポートをオープンし，受信／送信が可能な状態に
する．

(2) ER serial_cls_por(ID portid)

portidで指定されたシリアルポートをクローズする．

(3) ER_UINT serial_rea_dat(ID portid, char_t *buf, uint_t len)

portidで指定されたシリアルポートから，lenバイトの文字列を受信し，bufか
らの領域に入れる．lenバイト受信するまで，待ち状態となる．受信した文字数
またはエラーコードを返す．

(4) ER_UINT serial_wri_dat(ID portid, const char_t *buf, uint_t len)

portidで指定されたシリアルポートに，bufからのlenバイトの文字列を送信す
る．lenバイト送信バッファに入れるまで，待ち状態となる．送信した文字数ま
たはエラーコードを返す．

(5) ER serial_ctl_por(ID portid, uint_t ioctl)

portidで指定されたシリアルポートの制御情報を，ioctlで示される値に設定す
る．

ioctlには，以下の制御情報を表す定数を，ビット毎に論理和をとったものを
指定する．

	IOCTL_ECHO（エコーバックモード）
		このビットを設定すると，シリアルインタフェースドライバがエコー
		バックを行う．具体的には，バッファから文字を取り出す度に，その
		文字を書き出す．

	IOCTL_CRLF（改行モード）
		LF（line feed）を書き出すと，CR（carriage return）＋LFに変換し
		て書き出す．

	IOCTL_FCSND（送信フロー制御）
		文字を送信する処理に対して，XON/XOFFによるフロー制御を行う．
		すなわち，STOP（コントロール-S）を受信すると送信を停止し，
		START（コントロール-Q）を受信すると送信を再開する．

	IOCTL_FCANY（送信フロー制御で任意の文字で送信再開）
		IOCTL_FCSNDを指定している時に，送信停止中に受信した任意の文字
		で送信を再開する．

	IOCTL_FCRCV（受信フロー制御）
		文字を受信する処理に対して，XON/XOFFによるフロー制御を行う．
		すなわち，受信バッファの残り領域が少なくなるとSTOP（コントロー
		ル-S）を送出し，残り領域が増えればSTART（コントロール-Q）を送
		出する．

なお，オープン直後のデフォルトの設定値は(IOCTL_ECHO | IOCTL_CRLF |
IOCTL_FCSND | IOCTL_FCRCV)である．

(6) ER serial_ref_por(ID portid, T_SERIAL_RPOR *pk_rpor)

portidで指定されたシリアルポートの状態を参照し，pk_rporで指定されるパケッ
トに返す．パケット中のreacntには受信バッファ中の文字数を，wricntには送
信バッファ中の文字数を返す．

8.2.2 シリアルインタフェースドライバのその他のサービス

シリアルインタフェースドライバは，前記のサービスコールに加えて，初期化
処理と未送信文字の取出し処理を持つ．初期化処理は，カーネルに初期化ルー
チンとして登録する．また，ターゲット依存で，初期化処理，終了処理，割込
みサービスルーチンを持つ．これらの登録処理はserial.cfgに含まれる．

(1) void serial_initialize(intptr_t exinf)

シリアルインタフェースドライバを初期化する．カーネルに初期化ルーチンと
して登録する．exinfは無視する．

(2) bool_t serial_get_chr(ID portid, char_t *p_c)

portidで指定されたシリアルポートの送信バッファ中の文字を，p_cの指す番地
に取り出し，trueを返す関数．文字がなかった時には，falseを返す．終了処理
ルーチン中で呼び出すことを想定している．

8.3 システムログタスク

システムログタスクは，システムログ機能からログ情報を取り出し，それをシ
ステムの外部に出力するためのサービスである．

ASPカーネルのリリースパッケージに含まれるシステムログタスクは，シリアル
ポートにログ情報を文字列の形で出力するもので，システムログタスクの一例
という位置付けで提供している．

このシステムログタスクは，システムコンフィギュレーションファイルで
logtask.cfgをインクルードすることで，システムに組み込むことができる．シ
ステムログタスクのサービスを呼び出すソースファイルでは，logtask.hをイン
クルードする．

8.3.1 システムログタスクのサービスコール

システムログタスクのサービスを呼び出すサービスコールの仕様は次の通りで
ある．

(1) ER logtask_flush(uint_t count)

システムログ機能のログバッファ中のログ情報の数がcount以下になるまで待つ．
countが0の場合には，シリアルインタフェースドライバの送信バッファが空に
なるのも待つ．

8.3.2 システムログタスクのその他のサービス

システムログタスクは，前記のサービスコールに加えて，メイン処理と終了処
理を持つ．メイン処理はタスクとして，終了処理は終了処理ルーチンとして登
録する．これらの登録処理はlogtask.cfgに含まれる．

(1) void logtask_main(intptr_t exinf)

システムログタスクのメイン処理．exinfには，ログ情報を出力するシリアルポー
トのID番号を渡す．

(2) void logtask_terminate(intptr_t exinf)

システムログタスクの終了処理．シリアルインタフェースドライバの送信バッ
ファに蓄積されたデータと，ログバッファに記録されたログ情報を，低レベル
出力機能を用いて出力する．出力すべきログ情報がある場合には，それを出力
する前に，"-- buffered messages --"という文字列を出力する．exinfは無視
する．

この関数を終了処理ルーチンとして登録することで，カーネル終了時点で未出
力のログ情報のほとんどを出力することができる．ただし，未出力のログ情報
の内，システムログタスクのメイン処理がログバッファから取り出したが，ま
だシリアルインタフェースドライバに送信していない情報は，出力されない．

8.4 カーネル起動メッセージの出力

カーネル起動メッセージの出力は，カーネルの起動時に，カーネルの名称やバー
ジョン番号，著作権表示などを出力するための機能である．

カーネル起動メッセージの出力は，システムコンフィギュレーションファイル
でbanner.cfgをインクルードすることで，システムに組み込むことができる．

カーネル起動メッセージの出力は，次の関数で構成される．

(1) void print_banner(intptr_t exinf)

システムログ機能を用いて，カーネル起動メッセージを出力する．banner.cfg
によって，カーネルに初期化ルーチンとして登録される．exinfは無視される．


９．サポートライブラリ

サポートライブラリは，アプリケーションやシステムサービスを作成するため
に利用できるライブラリ関数群である．

9.1 基本的なライブラリ関数

基本的なライブラリ関数を用いる場合には，t_stdlib.hをインクルードする．

(1) const char *itron_strerror(ER ercd)

ercdで示されるエラーコードに対応するメインエラーコードの文字列を返す．

(2) void t_perror(uint_t prio, const char *file, int_t line,
										const char *expr, ER ercd);

サービスコールがエラーを返した場合に用いることを想定した関数で，ファイ
ル名，行番号，メインエラーコード等を，重要度prioで，システムログ機能を
用いて出力する．

9.2 システムログ出力用ライブラリ関数

システムログ出力用ライブラリ関数は，ログ情報をフォーマット出力するため
に，システムログタスクおよびシステムログ機能で用いるための関数群である．

システムログ出力用ライブラリ関数を呼び出すソースファイルでは，
log_output.hをインクルードする．

(1) void syslog_printf(const char *format, const intptr_t *args,
												void (*putc)(char_t))

formatで指定されるフォーマット記述とp_argsで指定される引数列から作成し
たメッセージを，1文字出力関数putcを用いて出力する．

(2) void syslog_print(const SYSLOG *p_sys, void (*putc)(char_t))

p_syslogで指定されるログ情報を文字列に直し，1文字出力関数putcを用いて出
力する．

(3) void syslog_lostmsg(uint_t lost, void (*putc)(char_t))

lost個のログ情報が失われた旨のメッセージを，1文字出力関数putcを用いて出
力する．

9.3 実行時間分布集計モジュール

実行時間分布集計モジュールは，システムのリアルタイム性能を評価するため
に，プログラム区間の実行時間を計測し，その分布を集計・表示するためのラ
イブラリ関数群である．

実行時間分布集計モジュールを呼び出すソースファイルでは，histgram.hをイ
ンクルードする．

実行時間分布集計モジュールは，複数のプログラム区間の実行時間を計測・集
計・表示することができる．プログラム区間毎に，実行時間分布を記録するた
めのデータ構造を持つ．どのデータ構造を用いるかを，ID番号（histid）で指
定する．使用できるデータ構造の数は，TNUM_HISTで定義される．TNUM_HISTの
デフォルト値は，histgram.hの中で定義されている．

実行時間分布集計モジュールは，カーネルの性能評価用システム時刻を参照す
る機能（get_utm）を用いて実行時間を計測する．そのため，実行時間はマイク
ロ秒単位で記録される（精度はターゲット依存）．また，記録される時間には，
計測のためのオーバヘッド（get_utmの実行時間＋α）が含まれる．

(1) void init_hist(ID histid, uint_t maxval, uint_t *hist)

histidで指定されたデータ構造を初期化する．maxvalには記録する最大時間を，
histには記録領域の先頭番地を指定する．histで始まる記憶領域は，要素数が
maxvalに指定した値+1のuint_t型の配列として確保する．例えば，maxvalに
1000を指定する場合には，histには要素数が1001のuint_t型の配列の先頭番地
を渡す．

(2) void begin_measure(ID histid)

実行時間を計測するプログラム区間の直前に呼び出す関数．histidで指定され
たデータ構造に，現在のシステム時刻を記録する．

(3) void end_measure(ID histid)

実行時間を計測するプログラム区間の直後に呼び出す関数．現在のシステム時
刻と，histidで指定されたデータ構造に記録された開始時刻から，プログラム
区間の実行時間を求め，その結果を記録する．

(4) void print_hist(ID histid)

システムログ機能を用いて，実行時間分布の計測結果を出力する．


１０．テストプログラム

テストプログラムは，カーネルの機能テストおよび性能評価を行うためのプロ
グラム群である．

10.1 テストプログラム用ライブラリ

テストプログラム用ライブラリは，プログラム中のチェックポイントが正しい
順序で実行されたことなど，プログラムが正しく動作していることをチェック
するための関数群である．プログラムが正しく動作していないことを検出した
場合には，プログラムを終了させる．

このライブラリ中でプログラムを終了させる時には，その時点で未出力のログ
情報等を出力しようとするが，一部の情報が抜ける場合がある．詳しくは，
「8.3.2 システムログタスクのその他のサービス」の節の(2)を参照すること．

テストプログラム用ライブラリ関数を用いる場合には，test_lib.hをインクルー
ドし，test_lib.cをコンパイル・リンクする．

(1) void check_point(uint_t count)

チェックポイントを通過する際に呼び出す関数．countには，何番目のチェック
ポイントであるかを指定する（最初のチェックポイントでは1を指定する）．
countの値が，最初のチェックポイントにおいては1でない場合に，それ以降の
チェックポイントにおいては，前のチェックポイント通過時にcountに指定した
値に1を加えた値でない場合に，プログラムが正しく動作していないと見なし，
プログラムを終了させる．

(2) void check_finish(uint_t count)

最後のチェックポイントに到達した際に呼び出す関数．countには，何番目の
チェックポイントであるかを指定する（最初のチェックポイントでは1を指定す
る）．countの値が，前のチェックポイント通過時にcountに指定した値に1を加
えた値でない場合に，プログラムが正しく動作していないと見なす．この関数
は，プログラムが正しく動作している／いないに関わらず，プログラムを終了
させる．

(3) void check_assert(bool_t exp)

expが真であることをチェックしたい場合に呼び出す関数．expが偽である場合
に，プログラムが正しく動作していないと見なし，プログラムを終了させる．

(4) void check_ercd(ER ercd, ER expected_ercd)

ercdがexpected_ercdに一致していることをチェックしたい場合に呼び出す関数．
ercdがexpected_ercdに一致していない場合に，プログラムが正しく動作してい
ないと見なし，プログラムを終了させる．

(5) void check_state(bool_t ctx, bool_t loc, PRI ipm,
						bool_t dsp, bool_t dpn, bool_t tex)

タスクコンテキストにおいて，システム状態が期待したものになっているか
チェックしたい時に呼び出す関数．ctx，loc，dsp，dpn，texにはそれぞれ
sns_ctx()，sns_loc()，sns_dsp()，sns_dpn()，sns_tex()の返値として期待さ
れる値を，ipmにはget_ipm()で参照できる割込み優先度マスクとして期待され
る値を指定する．この内のいずれかが期待される値と一致していない場合に，
プログラムが正しく動作していないと見なし，プログラムを終了させる．

(6) void check_state_i(bool_t ctx, bool_t loc,
						bool_t dsp, bool_t dpn, bool_t tex)

非タスクコンテキストにおいて，システム状態が期待したものになっているか
チェックしたい時に呼び出す関数．ctx，loc，dsp，dpn，texにはそれぞれ
sns_ctx()，sns_loc()，sns_dsp()，sns_dpn()，sns_tex()の返値として期待さ
れる値を指定する．この内のいずれかが期待される値と一致していない場合に，
プログラムが正しく動作していないと見なし，プログラムを終了させる．

(7) void set_bit_func(BIT_FUNC bit_func)

チェックポイントにおいて呼び出す自己診断関数を設定するための関数．

10.2 カーネルの整合性検査

チェックポイントにおいて呼び出す自己診断に使うためのプログラムとして，
カーネルの整合性検査を用意している．カーネルの整合性検査は，カーネル内
の各データ構造の一貫性を検査する（現時点では未完成）．

カーネルの整合性検査を用いる場合には，bit_kernel.cをコンパイル・リンク
する．

(1) ER bit_kernel(void)

カーネル内の各データ構造の一貫性を検査し，一貫性が確認できた場合にE_OK，
できなかった場合にE_SYSエラーを返す関数．E_SYSエラーを返す際のサブエラー
コードとして，一貫性が確認できなかった項目を示すコードを返す．

10.3 機能テストプログラム

testディレクトリに置かれた"test"で始まるプログラムは，カーネルの機能テ
ストを行うためのプログラムである．

現バージョンで用意している性能評価プログラムは次の通り．

(1) test_cpuexc1			CPU例外処理のテスト(1)
(2) test_cpuexc2			CPU例外処理のテスト(2)
(3) test_cpuexc3			CPU例外処理のテスト(3)
(4) test_cpuexc4			CPU例外処理のテスト(4)
(5) test_cpuexc5			CPU例外処理のテスト(5)
(6) test_cpuexc6			CPU例外処理のテスト(6)
(7) test_cpuexc7			CPU例外処理のテスト(7)
(8) test_cpuexc8			CPU例外処理のテスト(8)
(9) test_cpuexc9			CPU例外処理のテスト(9)
(10) test_cpuexc10			CPU例外処理のテスト(10)
(11) test_cpuexc11			CPU例外処理のテスト(11)
(12) test_cpuexc12			CPU例外処理のテスト(12)
(13) test_cpuexc13			CPU例外処理のテスト(13)
(14) test_dlynse			sil_dly_nseに関するテスト
(15) test_sem1				セマフォ機能のテスト(1)
(16) test_sysstat1			システム状態に関するテスト(1)
(17) test_task1				タスク管理モジュールのテスト(1)
(18) test_tex1				タスク例外処理に関するテスト(1)
(19) test_tex2				タスク例外処理に関するテスト(2)

10.4 性能評価プログラム

testディレクトリに置かれた"perf"で始まるプログラムは，カーネルの性能評
価を行うためのプログラムである．

性能評価プログラムは，計測対象となる処理を繰り返し実行し，その実行時間
を計測して，実行時間分布を表示する．

計測した実行時間には，時間計測のオーバヘッド（時間計測処理の実行にかか
る時間）が含まれる．計測対象の処理の正味の実行時間を求めるためには，計
測された時間から，時間計測のオーバヘッドを計測するためのプログラム
（perf0）で計測された時間を減算する必要がある．

また，実行時間の計測は，別に記述がない限り割込みを許可したまま行うため，
割込みハンドラ（少なくとも，タイマ割込みハンドラ）の処理時間が含まれた
実行結果が計測される．

なお，実行時間の計測中は，システムログタスクは強制待ちとしているため，
システムログタスクが影響することはない．

カーネルの性能評価にあたっては，ハードウェア（特にキャッシュ）の設定に
留意する必要がある．

現バージョンで用意している性能評価プログラムは次の通り．

(1) perf0		時間計測のオーバヘッドの評価

時間計測のオーバヘッドを計測するためのプログラム．具体的には，空のプロ
グラム（begin_mearsureとend_measureを続けて呼び出すプログラム）の実行時
間を計測する．

他の性能評価プログラムで計測された時間から，このプログラムで計測された
時間を減算した時間が，計測対象の処理の正味の実行時間である．

(2) perf1		slp_tsk，wup_tskによるタスク切換え時間の評価

slp_tsk，wup_tskによるタスク切換え時間を計測するためのプログラム．具体
的には，高い優先度のタスクが起床待ち状態である時に，低い優先度のタスク
がwup_tskにより高い優先度のタスクを起床し，高い優先度のタスクに切り換わ
るまでの時間と，高い優先度のタスクがslp_tskにより起床待ち状態となり，低
い優先度のタスクに切り換わるまでの時間を計測する．

(3) perf2		snd_pdqの処理時間の評価

優先度データキューに蓄積されているデータの数により，snd_pdqの処理時間が
どのように変化するかを計測するためのプログラム．具体的には，優先度デー
タキュー中に高い優先度のデータがn個蓄積されている時に，snd_dtqにより低
い優先度のデータを入れるのにかかる時間を計測する．nを0，10，20，30，40，
50，100，200，300と変化させて計測する．

(4) perf3		set_flgの処理時間の評価

待ち解除するタスクの数により，set_flgの処理時間がどのように変化するかを
計測するためのプログラム．具体的には，TA_WMUL属性のイベントフラグに対し
て，n個のタスクが待っている時に，set_flgによりそのすべてを待ち解除する
のにかかる時間を計測する．nを0，1，2，3，4，5，10，20と変化させて計測す
る．

１１．使用上のヒント

11.1 タイマドライバの組込み

タイマドライバをシステムに組み込むために，システムコンフィギュレーショ
ンファイルの先頭でtarget_timer.cfgをインクルードする必要がある．

11.2 assertマクロの処理

ASPカーネルのコード中には，assertマクロが使われている．assertマクロの定
義はt_stddef.hに含まれ，assertが失敗した場合の最後の処理（通常は，プロ
グラムを停止させる処理）は，ターゲット依存部のTOPPERS_assert_abortで決
定される．

assertが失敗した場合，システム開発中はデバッガに落とすのが望ましいが，
システム稼働時の対処法は，システムに対する要件に依存する．そこで，ター
ゲット依存部のTOPPERS_assert_abortを，システム要件に合致した適切な処理
に置き換える必要がある．システム要件によっては，NDEBUGを定義してassert
マクロの処理をオブジェクトコード中から消す（「6.2 コンパイルオプション」
の節を参照）方法も考えられる．

11.3 オブジェクトIDの管理

TOPPERS/ASPカーネルでは，オブジェクトのID番号を，コンフィギュレータが割
り付ける方法が基本となっている．

アプリケーションプログラム中でオブジェクトのID番号を参照する場合には，
次の2つの方法が考えられる．

(1) オブジェクト識別名を用いる

オブジェクト生成のための静的API（CRE_YYY）の第1パラメータに記述したオブ
ジェクト識別名を，アプリケーションプログラム中でも用いる方法．

コンフィギュレータは，オブジェクト識別名を，割り付けたID番号にマクロ定
義するC言語プリプロセッサのディレクティブ（#define）をkernel_cfg.hに生
成するため，アプリケーションプログラムからkernel_cfg.hをインクルードす
る必要がある．

この方法は，オブジェクトコード中にID番号が直接埋め込まれるために実行効
率が良い一方で，コンフィギュレータが実行されてkernel_cfg.hが書き換わる
度に，アプリケーションプログラムの再コンパイルが必要になるという欠点が
ある．そのため，アプリケーションプログラムを構成するファイルの中で，一
部のファイルのみでオブジェクト識別名を参照する構成にするといった工夫を
することが望ましい．

(2) オブジェクトのID番号を保持する変数を用いる

オブジェクトのID番号を保持するconst属性を付加した変数を用意し，アプリケー
ションプログラム中では，その変数を用いる方法．

例えば，TASK1というオブジェクト識別名のタスクに対して，次のような変数を
用意する．

const ID TASK1_id = TASK1;

アプリケーションプログラム中では，この変数（TASK1_id）を用いることで，
コンフィギュレータが実行されてkernel_cfg.hが書き換わる度に，上記の変数
定義を含んだファイルのみを再コンパイルすればよいことになる．

この方法は，アプリケーションプログラムの再コンパイルを最小限にできる利
点がある一方で，変数のためのメモリ領域が必要になることに加えて，（プロ
セッサによっては）変数アクセスのためのオーバヘッドが生じるという欠点が
ある．また，定数ではなく変数であることから，他の変数の初期化には使えな
いという制限がある．

なお，TOPPERS/ASPカーネルのコンフィギュレータは，--external-idオプショ
ンを付加することにより，上記の変数定義をkernel_cfg.c中に生成する機能を
持っているので，すべてのオブジェクトIDをこの方法で参照する場合には，こ
の機能を用いることを推奨する．

コンフィギュレータによるID番号割付けのもう1つの課題として，コンフィギュ
レーションファイルの修正により，オブジェクトIDの割付けが変わってしまう
ことが挙げられる．これは，アプリケーションソフトウェアの設計仕様書にID
番号が記載されている場合や，デバッグ作業においてID番号を直接扱っている
場合に，作業効率を低下させる可能性が考えられる．

この問題に対応するために，TOPPERS/ASPカーネルのコンフィギュレータに，
ID番号の割付け結果をファイルに書き出す機能（--id-output-fileオプション）
と，ID番号の割付けをファイルから取り込む機能（--id-input-fileオプション）
を用意している．これらの機能を用いて，コンフィギュレータを実行する度に，
前回に実行した時にファイルに書き出したID番号の割付けを取り込むことで，
前回実行時と同じ割付けを行うことができる．ただし，TOPPERS/ASPカーネルで
は，ID番号に抜けがあるのは許されないため，オブジェクトの数が減った場合
には（ID番号が大きい方のオブジェクトが減った場合を除いて）エラーとなる．
この場合には，ダミーのオブジェクトを生成する方法で回避するしかない．

11.4 カーネルの内部シンボルのリネーム

ASPカーネルでは，モジュール内部の名称が他のモジュール内部の名称と衝突す
ることを避けるために，カーネルの内部シンボルは，C言語レベルで，先頭が
"_kernel_"または"_KERNEL_"である名称としている．

これをソースコードの可読性と両立させるために，ASPカーネルでは，ソースコー
ドは自然な名前を用いて記述し，C言語プリプロセッサのマクロ定義（#define）
を用いて，それを"_kernel_"または"_KERNEL_"で始まる名前（自然な名前が
yyyyyの場合には，_kernel_yyyyy）にリネームする仕組みを用いている．

具体的には，関連するディレクトリにxxx_rename.defを置き，そこからリネー
ムのためのヘッダファイル（xxx_rename.hおよびxxx_unrename.h）を生成する
ツール（utils/genrename）を用意している．

この仕組みは，ソースコードの可読性向上に役立つ一方で，弊害もある．例え
ば，多くのデバッガで，ソースコード中の名称とオブジェクトコード中の名称
が異なるために，ソースコード中の変数名を指定して値を読んだり，関数名を
指定してブレークポイントを置くといったことができない．

この状況に対応するために，ASPカーネルでは，ソースコード中の該当する名称
をリネームするためのユーティリティ（utils/applyrename）を用意している．
applyrenameユーティリティに，リネーム定義ファイル（xxx_rename.def）のプ
リフィックス（xxxの部分）と，リネームしたいファイルリストを与えると，リ
ネーム処理を行なう．例えば，kernelディレクトリのすべてのファイルに対し
て，カーネルの内部シンボルをリネームするには，次のコマンドを実行すれば
よい．

	% cd kernel
	% ../utils/applyrename kernel *

また，ターゲット依存部のディレクトリのすべてのファイルに対して，カーネ
ルの内部シンボルをリネームするには，次のようなコマンドを実行すればよい．

	% cd target/dve68k_gcc/
	% ../../utils/applyrename target *
	% ../../utils/applyrename ../../kernel/kernel *

11.5 トレースログ記録のサンプルコードの使用方法

トレースログ記録のサンプルコードがターゲット依存部に組み込まれている場
合には，コンフィギュレーションスクリプトにそれを使用することを指示する
オプション（-r）を付加することで，メモリ上にトレースログを記録する機能
が有効になる．

トレースログ記録の使用方法の一例として，システム起動時にトレースログの
記録を開始し，システム終了時に記録したトレースログをダンプするためには，
システムコンフィギュレーションファイルに次のような記述を追加する．

	#include "logtrace/trace_config.h"
	ATT_INI({ TA_NULL, TRACE_AUTOSTOP, trace_initialize });
	ATT_TER({ TA_NULL, target_fput_log, trace_dump });

ここで，初期化ルーチン（trace_initialize）への引数は，初期化直後のトレー
スログの動作モードを指定するものである．指定できる動作モードについては，
arch/logtrace/trace_config.h中のコメントに説明がある．

終了処理ルーチン（trace_dump）は，記録されたトレースログをターゲット依
存の低レベル出力機能（target_fput_log）を利用してダンプするためのもので
ある．トレースログを別の方法で取り出す場合には，終了処理ルーチンを登録
する必要はない．


１２．参考情報

12.1 利用条件と利用報告

ASPカーネルの利用条件は，各ファイルの先頭に表示されている．著作権は，各
ファイルの先頭に表示されている著作権者が保有している．

利用条件の(3)の(b)において，利用の形態をTOPPERSプロジェクトに報告する方
法としては，ASPカーネルを利用した製品の名称と応用分野，製品化した会社名
と業種等の情報を，以下のURLのページから報告するものとする．

	http://www.toppers.jp/report.html

またその際に，ASPカーネルを使用してのコメントやご意見もいただけると幸い
である．

12.2 保証・適用性・サポート

ASPカーネルは無保証で提供されているものである．開発者およびTOPPERSプロ
ジェクトは，ASPカーネルに関して，特定の使用目的に対する適合性も含めて，
いかなる保証も行わない．また，ASPカーネルの利用により直接的または間接的
に生じたいかなる損害に関しても，その責任を負わない．

開発者およびTOPPERSプロジェクトは，ASPカーネルに関するサポートの約束は
していない．ASPカーネルに関して質問がある場合は，後述のTOPPERSユーザー
ズメーリングリストを利用していただけると幸いである．確実なサポートが必
要な場合には，有償でサポートサービスを提供している会社に相談されたい．

12.3 バグレポート

ASPカーネルにバグや問題点を発見された場合には，後述のTOPPERSユーザーズ
メーリングリストに報告して欲しい．

メーリングリストにバグや問題点などを報告する場合には，必要に応じて次の
情報を知らせて欲しい．

	使用しているカーネルに関する情報
		・ターゲット非依存部のバージョン
		・使用しているターゲット依存部とそのバージョン
		・TOPPERSプロジェクトからのリリースに対する改造箇所（あれば）

	ターゲットシステムに関する情報
		・ターゲットプロセッサの種類
		・ターゲットボード等の種類

	ホストに関する情報
		・OSのバージョン（サービスパックの適用状況も）
		・コンパイラなどの開発環境のバージョン（Cygwinのバージョンも）

12.4 ウェブサイト

TOPPERSプロジェクトのウェブサイトは，以下のURLにある．

	http://www.toppers.jp/

TOPPERSプロジェクトやASPカーネルに関する最新情報は，このウェブサイトか
ら得ることができる．また，ASPカーネルの最新版は，このウェブサイトからダ
ウンロードすることができる．

12.5 TOPPERSユーザーズメーリングリスト

ASPカーネルを含むTOPPERSプロジェクトの開発成果物のユーザに対する情報提
供およびユーザ相互間の情報交換を容易にするために，TOPPERSユーザーズメー
リングリスト（users@toppers.jp）を用意している．

このメーリングリストには，誰でも自由に登録し，メールを送付することがで
きる（登録者以外はメールを送付できない）．また，送付されたメールは，誰
でも自由にウェブサイトで読むことができる．

メーリングリストへの登録方法については，以下のURLのページに説明がある．

	http://www.toppers.jp/community.html

12.6 TOPPERSプロジェクトのメンバ向けのサービス

TOPPERSプロジェクトのメンバに対しては，上記に加えて，ASPカーネルに関連
して次のサービスを用意している．

(1) TOPPERS開発者メーリングリスト

TOPPERSプロジェクトのメンバは，ASPカーネルに関する質問，バグや問題点な
どの報告に，TOPPERS開発者メーリングリスト（dev@toppers.jp）を利用するこ
とができる．

(2) ASPカーネルの開発支援サイト

ASPカーネルの開発支援のためのTRAC（バグトラッキングシステム）が，以下の
URLにある（TRACへのアクセスには，会員パスワードが必要である）．

	http://dev.toppers.jp/proj/asp/

TOPPERSプロジェクトのメンバは，このサイトから，ウェブインタフェースおよ
びsubversionサーバにより，ASPカーネルの開発中のバージョンを得ることがで
きる．また，バグトラッキングデータベースにアクセスすることができ，過去
のバグ履歴へのアクセスや，バグの登録をすることができる．

12.7 TOPPERSプロジェクトへの参加

TOPPERSプロジェクトでは，何からの形でプロジェクトに貢献していただける方，
プロジェクトで開発したソフトウェアをお使いの方，プロジェクトに興味をお
持ちの方の参加を求めている．TOPPERSプロジェクトへの参加方法については，
以下のページに説明がある．

	http://www.toppers.jp/joinus.html


１３．リファレンス

13.1 サービスコール一覧

(1) タスク管理機能

	ER ercd = act_tsk(ID tskid)
	ER ercd = iact_tsk(ID tskid)
	ER_UINT	actcnt = can_act(ID tskid)
	ER ercd = ext_tsk(void)
	ER ercd = ter_tsk(ID tskid)
	ER ercd = chg_pri(ID tskid, PRI tskpri)
	ER ercd = get_pri(ID tskid, PRI *p_tskpri)
	ER ercd = get_inf(intptr_t *p_exinf)
	ER ercd = ref_tsk(ID tskid, T_RTSK *pk_rtsk)

(2) タスク付属同期機能

	ER ercd = slp_tsk(void)
	ER ercd = tslp_tsk(TMO tmout)
	ER ercd = wup_tsk(ID tskid)
	ER ercd = iwup_tsk(ID tskid)
	ER_UINT wupcnt = can_wup(ID tskid)
	ER ercd = rel_wai(ID tskid)
	ER ercd = irel_wai(ID tskid)
	ER ercd = sus_tsk(ID tskid)
	ER ercd = rsm_tsk(ID tskid)
	ER ercd = dly_tsk(RELTIM dlytim)

(3) タスク例外処理機能

	ER ercd = ras_tex(ID tskid, TEXPTN rasptn)
	ER ercd = iras_tex(ID tskid, TEXPTN rasptn)
	ER ercd = dis_tex(void)
	ER ercd = ena_tex(void)
	bool_t state = sns_tex(void)
	ER ercd = ref_tex(ID tskid, T_RTEX *pk_rtex)

(4) 同期・通信機能

	ER ercd = sig_sem(ID semid)
	ER ercd = isig_sem(ID semid)
	ER ercd = wai_sem(ID semid)
	ER ercd = pol_sem(ID semid)
	ER ercd = twai_sem(ID semid, TMO tmout)
	ER ercd = ini_sem(ID semid)
	ER ercd = ref_sem(ID semid, T_RSEM *pk_rsem)

	ER ercd = set_flg(ID flgid, FLGPTN setptn)
	ER ercd = iset_flg(ID flgid, FLGPTN setptn)
	ER ercd = clr_flg(ID flgid, FLGPTN clrptn)
	ER ercd = wai_flg(ID flgid, FLGPTN waiptn,
						MODE wfmode, FLGPTN *p_flgptn)
	ER ercd = pol_flg(ID flgid, FLGPTN waiptn,
						MODE wfmode, FLGPTN *p_flgptn)
	ER ercd = twai_flg(ID flgid, FLGPTN waiptn,
						MODE wfmode, FLGPTN *p_flgptn, TMO tmout)
	ER ercd = ini_flg(ID flgid)
	ER ercd = ref_flg(ID flgid, T_RFLG *pk_rflg)

	ER ercd = snd_dtq(ID dtqid, intptr_t data)
	ER ercd = psnd_dtq(ID dtqid, intptr_t data)
	ER ercd = ipsnd_dtq(ID dtqid, intptr_t data)
	ER ercd = tsnd_dtq(ID dtqid, intptr_t data, TMO tmout)
	ER ercd = fsnd_dtq(ID dtqid, intptr_t data)
	ER ercd = ifsnd_dtq(ID dtqid, intptr_t data)
	ER ercd = rcv_dtq(ID dtqid, intptr_t *p_data)
	ER ercd = prcv_dtq(ID dtqid, intptr_t *p_data)
	ER ercd = trcv_dtq(ID dtqid, intptr_t *p_data, TMO tmout)
	ER ercd = ini_dtq(ID dtqid)
	ER ercd = ref_dtq(ID dtqid, T_RDTQ *pk_rdtq)

	ER ercd = snd_pdq(ID pdqid, intptr_t data, PRI datapri)
	ER ercd = psnd_pdq(ID pdqid, intptr_t data, PRI datapri)
	ER ercd = ipsnd_pdq(ID pdqid, intptr_t data, PRI datapri)
	ER ercd = tsnd_pdq(ID pdqid, intptr_t data, PRI datapri, TMO tmout)
	ER ercd = rcv_pdq(ID pdqid, intptr_t *p_data, PRI *p_datapri)
	ER ercd = prcv_pdq(ID pdqid, intptr_t *p_data, PRI *p_datapri)
	ER ercd = trcv_pdq(ID pdqid, intptr_t *p_data, PRI *p_datapri, TMO tmout)
	ER ercd = ini_pdq(ID pdqid)
	ER ercd = ref_pdq(ID pdqid, T_RPDQ *pk_rpdq)

	ER ercd = snd_mbx(ID mbxid, T_MSG *pk_msg)
	ER ercd = rcv_mbx(ID mbxid, T_MSG **ppk_msg)
	ER ercd = prcv_mbx(ID mbxid, T_MSG **ppk_msg)
	ER ercd = trcv_mbx(ID mbxid, T_MSG **ppk_msg, TMO tmout)
	ER ercd = ini_mbx(ID mbxid)
	ER ercd = ref_mbx(ID mbxid, T_RMBX *pk_rmbx)

(5) メモリプール管理機能

	ER ercd = get_mpf(ID mpfid, void **p_blk)
	ER ercd = pget_mpf(ID mpfid, void **p_blk)
	ER ercd = tget_mpf(ID mpfid, void **p_blk, TMO tmout)
	ER ercd = rel_mpf(ID mpfid, void *blk)
	ER ercd = ini_mpf(ID mpfid)
	ER ercd = ref_mpf(ID mpfid, T_RMPF *pk_rmpf)

(6) 時間管理機能

	ER ercd = get_tim(SYSTIM *p_systim)
	ER ercd = get_utm(SYSUTM *p_sysutm)

	ER ercd = sta_cyc(ID cycid)
	ER ercd = stp_cyc(ID cycid)
	ER ercd = ref_cyc(ID cycid, T_RCYC *pk_rcyc)

	ER ercd = sta_alm(ID almid, RELTIM almtim)
	ER ercd = ista_alm(ID almid, RELTIM almtim)
	ER ercd = stp_alm(ID almid)
	ER ercd = istp_alm(ID almid)
	ER ercd = ref_alm(ID almid, T_RALM *pk_ralm)

(7) システム状態管理機能

	ER ercd = rot_rdq(PRI tskpri)
	ER ercd = irot_rdq(PRI tskpri)
	ER ercd = get_tid(ID *p_tskid)
	ER ercd = iget_tid(ID *p_tskid)
	ER ercd = loc_cpu(void)
	ER ercd = iloc_cpu(void)
	ER ercd = unl_cpu(void)
	ER ercd = iunl_cpu(void)
	ER ercd = dis_dsp(void)
	ER ercd = ena_dsp(void)
	bool_t state = sns_ctx(void)
	bool_t state = sns_loc(void)
	bool_t state = sns_dsp(void)
	bool_t state = sns_dpn(void)
	bool_t state = sns_ker(void)
	ER ercd = ext_ker(void)

(8) 割込み管理機能

	ER ercd = dis_int(INTNO intno)
	ER ercd = ena_int(INTNO intno)
	ER ercd = chg_ipm(PRI intpri)
	ER ercd = get_ipm(PRI *p_intpri)

(9) CPU例外管理機能

	bool_t stat = xsns_dpn(void *p_excinf)
	bool_t stat = xsns_xpn(void *p_excinf)

13.2 静的API一覧

(1) タスク管理機能

	CRE_TSK(ID tskid, { ATR tskatr, intptr_t exinf, TASK task,
								PRI itskpri, SIZE stksz, STK_T *stk })

(3) タスク例外処理機能

	DEF_TEX(ID tskid, { ATR texatr, TEXRTN texrtn })

(4) 同期・通信機能

	CRE_SEM(ID semid, { ATR sematr, uint_t isemcnt, uint_t maxsem })
	CRE_FLG(ID flgid, { ATR flgatr, FLGPTN iflgptn })
	CRE_DTQ(ID dtqid, { ATR dtqatr, uint_t dtqcnt, void *dtqmb })
	CRE_PDQ(ID pdqid, { ATR pdqatr, uint_t pdqcnt, PRI maxdpri, void *pdqmb })
	CRE_MBX(ID mbxid, { ATR mbxatr, PRI maxmpri, void *mprihd })

(5) メモリプール管理機能

	CRE_MPF(ID mpfid, { ATR mpfatr, uint_t blkcnt, uint_t blksz,
										MPF_T *mpf, void *mpfmb })

(6) 時間管理機能

	CRE_CYC(ID cycid, { ATR cycatr, intptr_t exinf, CYCHDR cychdr,
								RELTIM cyctim, RELTIM cycphs })
	CRE_ALM(ID almid, { ATR almatr, intptr_t exinf, ALMHDR almhdr })

(8) 割込み管理機能

	ATT_ISR({ ATR isratr, intptr_t exinf, INTNO intno, ISR isr, PRI isrpri })
	DEF_INH(INHNO inhno, { ATR inhatr, INTHDR inthdr })
	CFG_INT(INTNO intno, { ATR intatr, PRI intpri })

(9) CPU例外管理機能

	DEF_EXC(EXCNO excno, { ATR excatr, EXCHDR exchdr })

(10) システム構成管理機能

	DEF_ICS({ SIZE istksz, STK_T *istk })
	ATT_INI({ ATR iniatr, intptr_t exinf, INIRTN inirtn })
	ATT_TER({ ATR teratr, intptr_t exinf, TERRTN terrtn })

13.3 バージョン履歴

	2006年10月29日	Release	1.A.0		最初のリリース
	2007年2月20日	Release	1.A.1
	2007年2月20日	Release	1.A.2
	2007年7月12日	Release	1.B.0		コンフィギュレータを新バージョンに
	2007年7月12日	Release	1.B.1		ライセンス条件の入れ換え
	2007年7月16日	Release	1.B.2
	2007年7月21日	Release	1.B.3		ディレクトリ構成の変更
	2007年8月20日	Release	1.B.4		拡張パッケージの追加
	2007年10月16日	Release 1.B.5
	2007年11月15日	Release 1.0.0		正式版のリリース
	2007年12月23日	Release 1.1.0
	2008年3月19日	Release 1.2.0
	2008年3月21日	Release 1.2.1
	2008年4月12日	Release 1.3.0		一般公開に向けての最終修正
	2008年5月13日	Release 1.3.1		最初の一般公開版
	2008年8月21日	Release 1.3.2

以上
